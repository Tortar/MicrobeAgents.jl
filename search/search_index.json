{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"src/","text":"MicrobeAgents.jl MicrobeAgents.jl is a Julia framework for agent-based simulations of bacterial motility and chemotaxis, built on the amazing Agents.jl . Features Runs in 1, 2 and 3 spatial dimensions. Provides various motility patterns (Run-Tumble, Run-Reverse, Run-Reverse-Flick), all with customizable speed and turn angle distributions. Various models of bacterial chemotaxis (Brown & Berg, PNAS 1974; Celani & Vergassola, PNAS 2010; Xie et al, Biophys J 2014; Brumley et al, PNAS 2019). Fast analysis routines for common quantities of interest (run statistics, MSD, autocorrelation functions, drift velocity). Limitations (some may be temporary, others may be not) Only continuous space models are supported Reorientations are always assumed to be instantaneous; this approximation is really only reasonable when the integration timestep is above 50ms. Integration timestep also sets the sensory integration timescale in chemotactic models. What this package is not good for Although, in principle, you can add arbitrary layers of complexity on top the provided interface, there are a few things for which this package is not a recommended choice. - Hydrodynamic interactions. - Atomistic representation of biochemical pathways. Contribute The package is still in an early stage of intense development. If you would like to have support for your favorite model of chemotaxis, or need some specific features to be implemented, please open an issue. I'll try to satisfy as many requests as possible. If you would like to take a more active part in the development, please consider contacting me directly at rfoffi@ethz.ch. Citation If you use this package in work that leads to a publication, please cite the GitHub repository: @misc{Foffi2023, author = {Foffi, R.}, title = {MicrobeAgents.jl}, year = {2023}, publisher = {GitHub}, journal = {GitHub repository}, howpublished = {\\url{https://github.com/mastrof/MicrobeAgents.jl}} } Acknowledgements This project has received funding from the European Union's Horizon 2020 research and innovation programme under the Marie Sk\u0142odowska-Curie grant agreement No 955910.","title":"MicrobeAgents.jl"},{"location":"src/#microbeagentsjl","text":"MicrobeAgents.jl is a Julia framework for agent-based simulations of bacterial motility and chemotaxis, built on the amazing Agents.jl .","title":"MicrobeAgents.jl"},{"location":"src/#features","text":"Runs in 1, 2 and 3 spatial dimensions. Provides various motility patterns (Run-Tumble, Run-Reverse, Run-Reverse-Flick), all with customizable speed and turn angle distributions. Various models of bacterial chemotaxis (Brown & Berg, PNAS 1974; Celani & Vergassola, PNAS 2010; Xie et al, Biophys J 2014; Brumley et al, PNAS 2019). Fast analysis routines for common quantities of interest (run statistics, MSD, autocorrelation functions, drift velocity).","title":"Features"},{"location":"src/#limitations-some-may-be-temporary-others-may-be-not","text":"Only continuous space models are supported Reorientations are always assumed to be instantaneous; this approximation is really only reasonable when the integration timestep is above 50ms. Integration timestep also sets the sensory integration timescale in chemotactic models.","title":"Limitations (some may be temporary, others may be not)"},{"location":"src/#what-this-package-is-not-good-for","text":"Although, in principle, you can add arbitrary layers of complexity on top the provided interface, there are a few things for which this package is not a recommended choice. - Hydrodynamic interactions. - Atomistic representation of biochemical pathways.","title":"What this package is not good for"},{"location":"src/#contribute","text":"The package is still in an early stage of intense development. If you would like to have support for your favorite model of chemotaxis, or need some specific features to be implemented, please open an issue. I'll try to satisfy as many requests as possible. If you would like to take a more active part in the development, please consider contacting me directly at rfoffi@ethz.ch.","title":"Contribute"},{"location":"src/#citation","text":"If you use this package in work that leads to a publication, please cite the GitHub repository: @misc{Foffi2023, author = {Foffi, R.}, title = {MicrobeAgents.jl}, year = {2023}, publisher = {GitHub}, journal = {GitHub repository}, howpublished = {\\url{https://github.com/mastrof/MicrobeAgents.jl}} }","title":"Citation"},{"location":"src/#acknowledgements","text":"This project has received funding from the European Union's Horizon 2020 research and innovation programme under the Marie Sk\u0142odowska-Curie grant agreement No 955910.","title":"Acknowledgements"},{"location":"src/api/","text":"API Data analysis @docs msd acf driftvelocity_direction driftvelocity_point detect_turns rundurations mean_runduration mean_turnrate","title":"API"},{"location":"src/api/#api","text":"","title":"API"},{"location":"src/api/#data-analysis","text":"@docs msd acf driftvelocity_direction driftvelocity_point detect_turns rundurations mean_runduration mean_turnrate","title":"Data analysis"},{"location":"src/chemotaxis/","text":"Chemotaxis Linear concentration ramp As a first step into the world of chemotaxis, we will reproduce an in-silico version of a classical laboratory assay: a linear concentration ramp in a rectangular channel. We will use the BrownBerg model. To define concentration profiles, MicrobeAgents.jl expects three functions: concentration_field , concentration_gradient and concentration_time_derivative , all of which must have a method with signature (pos,model) , i.e. they take as input a microbe position and the ABM object. In this example the field is static, so we won't define a time derivative. using MicrobeAgents @inline function concentration_field(pos, model) C\u2080 = model.C\u2080 C\u2081 = model.C\u2081 Lx = first(spacesize(model)) concentration_field(pos,Lx,C\u2080,C\u2081) end @inline concentration_field(pos,Lx,C\u2080,C\u2081) = C\u2080 + (C\u2081-C\u2080)*pos[1]/Lx @inline function concentration_gradient(pos, model) C\u2080 = model.C\u2080 C\u2081 = model.C\u2081 Lx = first(spacesize(model)) concentration_gradient(pos,Lx,C\u2080,C\u2081) end @inline concentration_gradient(pos,Lx,C\u2080,C\u2081) = ntuple(i->i==1 ? (C\u2081-C\u2080)/Lx : 0.0, length(pos)) The quantities C\u2080 and C\u2081 represent the concentration values at left ( x=0 ) and right ( x=L ) edges of the channel. Notice that concentration_gradient returns a Tuple with the same size as pos , not just a Number . This is required since the gradient is a vector quantity. We can set up the ABM as usual, but we will need to supply :concentration_field and :concentration_gradient to the properties container, as well as :C\u2080 and :C\u2081 . Then we can run the simulation and make a nice plot. Lx, Ly = 3000, 1500 extent = (Lx, Ly) periodic = false space = ContinuousSpace(extent; periodic) \u0394t = 0.1 # timestep (s) T = 120 # simulation time (s) nsteps = round(Int, T/\u0394t) n = 100 C\u2080, C\u2081 = 0.0, 20.0 # \u03bcM properties = Dict( :C\u2080 => C\u2080, :C\u2081 => C\u2081, :concentration_field => concentration_field, :concentration_gradient => concentration_gradient ) model = StandardABM(BrownBerg{2}, space, \u0394t; periodic, properties, container=Vector) for i in 1:n add_agent!(model) end adata = [:pos] adf, mdf = run!(model, nsteps; adata) traj = vectorize_adf_measurement(adf, :pos) x = first.(traj) y = last.(traj) ts = unique(adf.step) .* \u0394t lw = eachindex(ts) ./ length(ts) .* 3 xmesh = range(0,Lx,length=100) ymesh = range(0,Ly,length=100) xn = @view x[:,1:10] yn = @view y[:,1:10] c = concentration_field.(Iterators.product(xmesh,ymesh),Lx,C\u2080,C\u2081) heatmap(xmesh, ymesh, c', cbar=false, ratio=1, axis=false, c=:bone) plot!(xn, yn, lab=false, lw=lw, lc=(1:n)') scatter!(xn[end,:], yn[end,:], lab=false, m=:c, mc=1:n, msw=0.5, ms=8)","title":"Chemotaxis"},{"location":"src/chemotaxis/#chemotaxis","text":"","title":"Chemotaxis"},{"location":"src/chemotaxis/#linear-concentration-ramp","text":"As a first step into the world of chemotaxis, we will reproduce an in-silico version of a classical laboratory assay: a linear concentration ramp in a rectangular channel. We will use the BrownBerg model. To define concentration profiles, MicrobeAgents.jl expects three functions: concentration_field , concentration_gradient and concentration_time_derivative , all of which must have a method with signature (pos,model) , i.e. they take as input a microbe position and the ABM object. In this example the field is static, so we won't define a time derivative. using MicrobeAgents @inline function concentration_field(pos, model) C\u2080 = model.C\u2080 C\u2081 = model.C\u2081 Lx = first(spacesize(model)) concentration_field(pos,Lx,C\u2080,C\u2081) end @inline concentration_field(pos,Lx,C\u2080,C\u2081) = C\u2080 + (C\u2081-C\u2080)*pos[1]/Lx @inline function concentration_gradient(pos, model) C\u2080 = model.C\u2080 C\u2081 = model.C\u2081 Lx = first(spacesize(model)) concentration_gradient(pos,Lx,C\u2080,C\u2081) end @inline concentration_gradient(pos,Lx,C\u2080,C\u2081) = ntuple(i->i==1 ? (C\u2081-C\u2080)/Lx : 0.0, length(pos)) The quantities C\u2080 and C\u2081 represent the concentration values at left ( x=0 ) and right ( x=L ) edges of the channel. Notice that concentration_gradient returns a Tuple with the same size as pos , not just a Number . This is required since the gradient is a vector quantity. We can set up the ABM as usual, but we will need to supply :concentration_field and :concentration_gradient to the properties container, as well as :C\u2080 and :C\u2081 . Then we can run the simulation and make a nice plot. Lx, Ly = 3000, 1500 extent = (Lx, Ly) periodic = false space = ContinuousSpace(extent; periodic) \u0394t = 0.1 # timestep (s) T = 120 # simulation time (s) nsteps = round(Int, T/\u0394t) n = 100 C\u2080, C\u2081 = 0.0, 20.0 # \u03bcM properties = Dict( :C\u2080 => C\u2080, :C\u2081 => C\u2081, :concentration_field => concentration_field, :concentration_gradient => concentration_gradient ) model = StandardABM(BrownBerg{2}, space, \u0394t; periodic, properties, container=Vector) for i in 1:n add_agent!(model) end adata = [:pos] adf, mdf = run!(model, nsteps; adata) traj = vectorize_adf_measurement(adf, :pos) x = first.(traj) y = last.(traj) ts = unique(adf.step) .* \u0394t lw = eachindex(ts) ./ length(ts) .* 3 xmesh = range(0,Lx,length=100) ymesh = range(0,Ly,length=100) xn = @view x[:,1:10] yn = @view y[:,1:10] c = concentration_field.(Iterators.product(xmesh,ymesh),Lx,C\u2080,C\u2081) heatmap(xmesh, ymesh, c', cbar=false, ratio=1, axis=false, c=:bone) plot!(xn, yn, lab=false, lw=lw, lc=(1:n)') scatter!(xn[end,:], yn[end,:], lab=false, m=:c, mc=1:n, msw=0.5, ms=8)","title":"Linear concentration ramp"},{"location":"src/firststeps/","text":"First steps Structure An AgentBasedModel object embeds all the properties of the system to be simulated and maps unique IDs to microbe instances. During the simulation, the model is evolved in discrete time steps, with each microbe's \"state\" being updated according to specified rules. Standard rules for motion, reorientations and chemotaxis are available by default, but custom behaviors can be implemented via user-defined functions. The typical workflow to run a simulation in MicrobeAgents.jl goes as follows: 1. Define the size and properties of the space in which the microbes will move. 2. Choose an appropriate microbe type to represent the desired behavior, or define a new one. 3. Initialize an AgentBasedModel object with the desired space, microbe type, integration time step, and any extra property needed for the simulation. 4. Populated the ABM with microbe instances. 5. Run the model (defining custom stepping functions if required) and collect data. MicrobeAgents.jl re-exports and extends various function from Agents.jl in order to work as a standalone, but it is generally recommended to use it in combination with Agents.jl for extra goodies. Space MicrobAgents.jl only supports continuous spaces with dimensions 1, 2 or 3. Spaces can be created with the ContinuousSpace function (reexported from Agents.jl). The extent of the space must be given as a tuple, and periodicity is set with the periodic kwarg (defaults to true). # one-dimensional periodic space extent = (1.0,) ContinuousSpace(extent) # two-dimensional non-periodic space extent = (1.0, 2.0) ContinuousSpace(extent; periodic=false) Microbes Microbes are represented by subtypes of the AbstractMicrobe type, which is in turn a subtype of AbstractAgent introduced by Agents.jl ```@docs AbstractMicrobe MicrobeAgents provides different `AbstractMicrobe` subtypes representing different models of bacterial behavior from the literature. A basic type, which is typically sufficient for simple motility simulations and does not include chemotaxis, is the `Microbe` type. ```@docs Microbe The dimensionality of Microbe must always be specified on creation. All the fields are instead optional, and if not specified will be assigned default values. To create a Microbe living in a 1-dimensional space, with default parameters ( RunTumble motility, average turn rate \\nu=1\\;s^{-1} , and no rotational diffusivity), it is therefore sufficient to run Microbe{1}() Similarly, for two and three dimensions: Microbe{2}() Microbe{3}() Any custom parameter can be set via kwargs: Microbe{3}( turn_rate = 0.6, rotational_diffusivity = 0.1 ) All the other subtypes of AbstractMicrobe work in a similar way, although they will have distinct default values and extra fields. Default values are typically assigned following the original implementation in the literature. ```@docs BrownBerg Brumley Celani Xie ## Creating a model MicrobeAgents.jl exploits the `AgentBasedModel` interface from Agents.jl. While the standard Agents.jl syntax will always work, it is typically more convenient to use the method extensions provided by MicrobeAgents.jl, which also includes some default parameters required by the simulations. Whenever removal of microbes during the simulation is not needed, it is recommended to call `StandardABM` with the `container=Vector` keyword argument to improve performance. ```@docs StandardABM To create a simple model, we just need to choose a microbe type, the size of the simulation domain and the integration timestep. The properties of the simulation domain are wrapped in the ContinuousSpace object. extent = (1000.0, 500.0) # size of 2D simulation domain space = ContinuousSpace(extent) dt = 0.1 # integration timestep model = StandardABM(Microbe{2}, space, dt) Now bacteria can be added with the add_agent! function. ```@docs add_agent! We need not specify anything if we want the microbe to be added at a random position with the default values from the constructor. add_agent!(model) The microbe will be now accessible as `model[1]`. ## Running a model After the model has been created and populated with the desired number of microbes, we are ready to run the simulation. We just need to specify how many steps we want to simulate and what data to collect during the run: nsteps = 100 adf, mdf = run!(model, nsteps; adata=[:pos]) `run!` will return two dataframes, one for the agent-level data (`adf`) and one for the model-level data (`mdf`, which in this case will be empty). This way, we have produced our first random walk. Since `adf.pos` is a vector of tuples, we first have to unpack the x and y values and then we are ready to plot our trajectory. using Plots x = first.(adf.pos) y = last.(adf.pos) plot(x, y) Notice that we did not specify at all how the timestepping is performed. MicrobAgents.jl implements a default timestepper which is applied to all `AbstractMicrobe` instances, which takes care of motion, rotational diffusion and reorientations. Each subtype is then equipped with its own `affect!` and `turnrate` functions (explained later) which determine extra behavioral features (such as chemotaxis). If different behavior is desired, the integration can be customized by passing custom timestepping functions to `run!`: run!(model, my_agent_step!, my_model_step!, nsteps) ## Motility patterns In MicrobeAgents.jl, motility patterns are represented as instances of `AbstractMotility`. In particular, currently available patterns are distinguished into two further categories: `AbstractMotilityOneStep` or `AbstractMotilityTwoStep`. ```@docs AbstractMotilityOneStep AbstractMotilityTwoStep One-step motility pattern are characterized by a single swimming stage. Two-step motility patterns instead have two stages which can have distinct properties; these two stages are referred to as \"forward\" and \"backward\" but can really represent anything. MicrobeAgents.jl defines three standard motility patterns: @docs RunTumble() RunReverse() RunReverseFlick() The default values provided by the constructors always consider a constant swimming speed of 30 (micron/s) and \"ideal\" turn-angle distributions (isotropic for tumbles, perfect 180 and 90 degree reorientations for reverse and flicks). For more accurate simulation where the reorientation statistics of the microbes is important, appropriate distributions should be specified; the constructors will accept any object that can be sampled via rand() .","title":"First steps"},{"location":"src/firststeps/#first-steps","text":"","title":"First steps"},{"location":"src/firststeps/#structure","text":"An AgentBasedModel object embeds all the properties of the system to be simulated and maps unique IDs to microbe instances. During the simulation, the model is evolved in discrete time steps, with each microbe's \"state\" being updated according to specified rules. Standard rules for motion, reorientations and chemotaxis are available by default, but custom behaviors can be implemented via user-defined functions. The typical workflow to run a simulation in MicrobeAgents.jl goes as follows: 1. Define the size and properties of the space in which the microbes will move. 2. Choose an appropriate microbe type to represent the desired behavior, or define a new one. 3. Initialize an AgentBasedModel object with the desired space, microbe type, integration time step, and any extra property needed for the simulation. 4. Populated the ABM with microbe instances. 5. Run the model (defining custom stepping functions if required) and collect data. MicrobeAgents.jl re-exports and extends various function from Agents.jl in order to work as a standalone, but it is generally recommended to use it in combination with Agents.jl for extra goodies.","title":"Structure"},{"location":"src/firststeps/#space","text":"MicrobAgents.jl only supports continuous spaces with dimensions 1, 2 or 3. Spaces can be created with the ContinuousSpace function (reexported from Agents.jl). The extent of the space must be given as a tuple, and periodicity is set with the periodic kwarg (defaults to true). # one-dimensional periodic space extent = (1.0,) ContinuousSpace(extent) # two-dimensional non-periodic space extent = (1.0, 2.0) ContinuousSpace(extent; periodic=false)","title":"Space"},{"location":"src/firststeps/#microbes","text":"Microbes are represented by subtypes of the AbstractMicrobe type, which is in turn a subtype of AbstractAgent introduced by Agents.jl ```@docs AbstractMicrobe MicrobeAgents provides different `AbstractMicrobe` subtypes representing different models of bacterial behavior from the literature. A basic type, which is typically sufficient for simple motility simulations and does not include chemotaxis, is the `Microbe` type. ```@docs Microbe The dimensionality of Microbe must always be specified on creation. All the fields are instead optional, and if not specified will be assigned default values. To create a Microbe living in a 1-dimensional space, with default parameters ( RunTumble motility, average turn rate \\nu=1\\;s^{-1} , and no rotational diffusivity), it is therefore sufficient to run Microbe{1}() Similarly, for two and three dimensions: Microbe{2}() Microbe{3}() Any custom parameter can be set via kwargs: Microbe{3}( turn_rate = 0.6, rotational_diffusivity = 0.1 ) All the other subtypes of AbstractMicrobe work in a similar way, although they will have distinct default values and extra fields. Default values are typically assigned following the original implementation in the literature. ```@docs BrownBerg Brumley Celani Xie ## Creating a model MicrobeAgents.jl exploits the `AgentBasedModel` interface from Agents.jl. While the standard Agents.jl syntax will always work, it is typically more convenient to use the method extensions provided by MicrobeAgents.jl, which also includes some default parameters required by the simulations. Whenever removal of microbes during the simulation is not needed, it is recommended to call `StandardABM` with the `container=Vector` keyword argument to improve performance. ```@docs StandardABM To create a simple model, we just need to choose a microbe type, the size of the simulation domain and the integration timestep. The properties of the simulation domain are wrapped in the ContinuousSpace object. extent = (1000.0, 500.0) # size of 2D simulation domain space = ContinuousSpace(extent) dt = 0.1 # integration timestep model = StandardABM(Microbe{2}, space, dt) Now bacteria can be added with the add_agent! function. ```@docs add_agent! We need not specify anything if we want the microbe to be added at a random position with the default values from the constructor. add_agent!(model) The microbe will be now accessible as `model[1]`. ## Running a model After the model has been created and populated with the desired number of microbes, we are ready to run the simulation. We just need to specify how many steps we want to simulate and what data to collect during the run: nsteps = 100 adf, mdf = run!(model, nsteps; adata=[:pos]) `run!` will return two dataframes, one for the agent-level data (`adf`) and one for the model-level data (`mdf`, which in this case will be empty). This way, we have produced our first random walk. Since `adf.pos` is a vector of tuples, we first have to unpack the x and y values and then we are ready to plot our trajectory. using Plots x = first.(adf.pos) y = last.(adf.pos) plot(x, y) Notice that we did not specify at all how the timestepping is performed. MicrobAgents.jl implements a default timestepper which is applied to all `AbstractMicrobe` instances, which takes care of motion, rotational diffusion and reorientations. Each subtype is then equipped with its own `affect!` and `turnrate` functions (explained later) which determine extra behavioral features (such as chemotaxis). If different behavior is desired, the integration can be customized by passing custom timestepping functions to `run!`: run!(model, my_agent_step!, my_model_step!, nsteps) ## Motility patterns In MicrobeAgents.jl, motility patterns are represented as instances of `AbstractMotility`. In particular, currently available patterns are distinguished into two further categories: `AbstractMotilityOneStep` or `AbstractMotilityTwoStep`. ```@docs AbstractMotilityOneStep AbstractMotilityTwoStep One-step motility pattern are characterized by a single swimming stage. Two-step motility patterns instead have two stages which can have distinct properties; these two stages are referred to as \"forward\" and \"backward\" but can really represent anything. MicrobeAgents.jl defines three standard motility patterns: @docs RunTumble() RunReverse() RunReverseFlick() The default values provided by the constructors always consider a constant swimming speed of 30 (micron/s) and \"ideal\" turn-angle distributions (isotropic for tumbles, perfect 180 and 90 degree reorientations for reverse and flicks). For more accurate simulation where the reorientation statistics of the microbes is important, appropriate distributions should be specified; the constructors will accept any object that can be sampled via rand() .","title":"Microbes"},{"location":"src/randomwalks/","text":"Random walks Generating random walks with MicrobeAgents.jl is super-easy, and the walk properties can be fine-tuned to match all sorts of needs. By default, MicrobeAgents.jl produces random walks composed of runs at constant speed and arbitrary reorientations where the waiting times between such reorientations are i.i.d. random variables. In the absence of chemotaxis (or other behavioral responses that affect microbe motility), the generated random walks will display an exponential distribution of waiting times. Random Walk in D=1 using MicrobeAgents L = 1000 space = ContinuousSpace((L,)) dt = 0.1 n = 10 nsteps = 600 model = StandardABM(Microbe{1}, space, dt; container=Vector) foreach(_ -> add_agent!((0,), model), 1:n) By default, ContinuousSpace will create a periodic domain; this will allow us to mimic an \"infinite\" system. All the microbes have been initialized from position 0, without specifying any further property, so they will be initialized with a random velocity (either (+1,) or (-1,) in this 1D scenario), speed=30.0 , and turn_rate=1.0 . The motility is set by default to RunTumble(speed=[30.0]) but any other motile pattern in 1D would produce the same result; only speed is relevant here. To run the simulation while collecting the bacterial positions at each step we will then run adata = [:pos] adf, _ = run!(model, nsteps; adata) The dataframe adf can now be turned into a matrix of positions, with each row representing a different timepoint, and each column a different microbe. And since we used periodic boundary conditions, the trajectories can be unfolded trajectories = MicrobeAgents.unfold(vectorize_adf_measurement(adf, :pos), L) trajectories is now a Matrix{Tuple{Float64}} . To obtain the x positions for plotting we can call x = first.(trajectories) t = axes(x,1) .* dt plot(t,x,lab=false,xlab=\"time\",ylab=\"displacement\") Random walks with different motile patterns in D=2 The procedure to generate a random walk in higher dimensions is exactly the same L = 500 space = ContinuousSpace((L,L)) dt = 0.1 nsteps = 600 model = StandardABM(Microbe{2}, space, dt; container=Vector) But we can now add bacteria with different motility patterns (we import Distributions.jl to use a Normal distribution for the speed of one of our microbes) using Distributions add_agent!(model; motility=RunReverse(speed_forward=[55]), rotational_diffusivity=0.2) add_agent!(model; motility=RunTumble(speed=Normal(30,6)), turn_rate=0.5) add_agent!(model; motility=RunReverseFlick(speed_backward=[6]), rotational_diffusivity=0.1) and then we run and visualize as before adata = [:pos] adf, _ = run!(model, nsteps; adata) # postprocessing traj = MicrobeAgents.unfold(vectorize_adf_measurement(adf,:pos), L) x = first.(traj) y = last.(traj) t = axes(x,1) .* dt plot(x, y, xlab=\"x\", ylab=\"y\", ratio=1, lab=[\"RunReverse\" \"RunTumble\" \"RunReverseFlick\"] )","title":"Random walks"},{"location":"src/randomwalks/#random-walks","text":"Generating random walks with MicrobeAgents.jl is super-easy, and the walk properties can be fine-tuned to match all sorts of needs. By default, MicrobeAgents.jl produces random walks composed of runs at constant speed and arbitrary reorientations where the waiting times between such reorientations are i.i.d. random variables. In the absence of chemotaxis (or other behavioral responses that affect microbe motility), the generated random walks will display an exponential distribution of waiting times.","title":"Random walks"},{"location":"src/randomwalks/#random-walk-in-d1","text":"using MicrobeAgents L = 1000 space = ContinuousSpace((L,)) dt = 0.1 n = 10 nsteps = 600 model = StandardABM(Microbe{1}, space, dt; container=Vector) foreach(_ -> add_agent!((0,), model), 1:n) By default, ContinuousSpace will create a periodic domain; this will allow us to mimic an \"infinite\" system. All the microbes have been initialized from position 0, without specifying any further property, so they will be initialized with a random velocity (either (+1,) or (-1,) in this 1D scenario), speed=30.0 , and turn_rate=1.0 . The motility is set by default to RunTumble(speed=[30.0]) but any other motile pattern in 1D would produce the same result; only speed is relevant here. To run the simulation while collecting the bacterial positions at each step we will then run adata = [:pos] adf, _ = run!(model, nsteps; adata) The dataframe adf can now be turned into a matrix of positions, with each row representing a different timepoint, and each column a different microbe. And since we used periodic boundary conditions, the trajectories can be unfolded trajectories = MicrobeAgents.unfold(vectorize_adf_measurement(adf, :pos), L) trajectories is now a Matrix{Tuple{Float64}} . To obtain the x positions for plotting we can call x = first.(trajectories) t = axes(x,1) .* dt plot(t,x,lab=false,xlab=\"time\",ylab=\"displacement\")","title":"Random Walk in D=1"},{"location":"src/randomwalks/#random-walks-with-different-motile-patterns-in-d2","text":"The procedure to generate a random walk in higher dimensions is exactly the same L = 500 space = ContinuousSpace((L,L)) dt = 0.1 nsteps = 600 model = StandardABM(Microbe{2}, space, dt; container=Vector) But we can now add bacteria with different motility patterns (we import Distributions.jl to use a Normal distribution for the speed of one of our microbes) using Distributions add_agent!(model; motility=RunReverse(speed_forward=[55]), rotational_diffusivity=0.2) add_agent!(model; motility=RunTumble(speed=Normal(30,6)), turn_rate=0.5) add_agent!(model; motility=RunReverseFlick(speed_backward=[6]), rotational_diffusivity=0.1) and then we run and visualize as before adata = [:pos] adf, _ = run!(model, nsteps; adata) # postprocessing traj = MicrobeAgents.unfold(vectorize_adf_measurement(adf,:pos), L) x = first.(traj) y = last.(traj) t = axes(x,1) .* dt plot(x, y, xlab=\"x\", ylab=\"y\", ratio=1, lab=[\"RunReverse\" \"RunTumble\" \"RunReverseFlick\"] )","title":"Random walks with different motile patterns in D=2"},{"location":"src/validation/","text":"Validation Run Time Distribution (examples/Analysis/run_distribution.jl) Run times should be exponentially distributed, with \\tau being the inverse of the average turn rate. The smaller the timestep \\Delta t compared to the average run length \\tau , the better the agreement between numerical results and theory. A ratio \\tau / \\Delta t \\sim 10 is typically sufficient to have a reasonable agreement. Velocity Autocorrelation Function Velocity autocorrelation functions for the three motility patterns should obey the following equations (Taktikos et al. PLoS ONE 2012): \\phi(t) = \\begin{cases} \\text{exp}(-t/\\tau), & \\text{run-tumble} \\\\ \\text{exp}(-2t/\\tau), & \\text{run-reverse} \\\\ (1-t/2\\tau)\\text{exp}(-t/\\tau), & \\text{run-reverse-flick} \\end{cases} (assuming no rotational diffusion, and that forward and backward mode have identical timescales for the run-reverse-flick swimmer). Mean Squared Displacement The mean squared displacement (MSD) for a run-tumble swimmer with average turn angle \\theta (and without rotational diffusion) should obey the following equation (Taktikos et al. PLoS ONE 2012): \\text{MSD}(t) = 2v^2\\tilde{\\tau}^2 (t/\\tilde{\\tau} - 1 + e^{-t/\\tilde{\\tau}}) where \\tilde{\\tau} = \\tau/(1-\\cos\\theta) .","title":"Validation"},{"location":"src/validation/#validation","text":"","title":"Validation"},{"location":"src/validation/#run-time-distribution","text":"(examples/Analysis/run_distribution.jl) Run times should be exponentially distributed, with \\tau being the inverse of the average turn rate. The smaller the timestep \\Delta t compared to the average run length \\tau , the better the agreement between numerical results and theory. A ratio \\tau / \\Delta t \\sim 10 is typically sufficient to have a reasonable agreement.","title":"Run Time Distribution"},{"location":"src/validation/#velocity-autocorrelation-function","text":"Velocity autocorrelation functions for the three motility patterns should obey the following equations (Taktikos et al. PLoS ONE 2012): \\phi(t) = \\begin{cases} \\text{exp}(-t/\\tau), & \\text{run-tumble} \\\\ \\text{exp}(-2t/\\tau), & \\text{run-reverse} \\\\ (1-t/2\\tau)\\text{exp}(-t/\\tau), & \\text{run-reverse-flick} \\end{cases} (assuming no rotational diffusion, and that forward and backward mode have identical timescales for the run-reverse-flick swimmer).","title":"Velocity Autocorrelation Function"},{"location":"src/validation/#mean-squared-displacement","text":"The mean squared displacement (MSD) for a run-tumble swimmer with average turn angle \\theta (and without rotational diffusion) should obey the following equation (Taktikos et al. PLoS ONE 2012): \\text{MSD}(t) = 2v^2\\tilde{\\tau}^2 (t/\\tilde{\\tau} - 1 + e^{-t/\\tilde{\\tau}}) where \\tilde{\\tau} = \\tau/(1-\\cos\\theta) .","title":"Mean Squared Displacement"},{"location":"src/examples/randomwalk1D/","text":"@meta EditURL = \"../../../examples/RandomWalks/randomwalk1D.jl\" ````@example randomwalk1D using MicrobeAgents using Plots model parameters L = 1000 space = ContinuousSpace((L,)) dt = 0.1 n = 10 nsteps = 600 abm setup model = StandardABM(Microbe{1}, space, dt) foreach(_ -> add_agent!((0,), model), 1:n) simulation adata = [:pos] adf, _ = run!(model, nsteps; adata) postprocessing traj = MicrobeAgents.unfold(vectorize_adf_measurement(adf,:pos), L) x = first.(traj) t = axes(x,1) .* dt visualization plot(t, x, leg=false, xlab=\"time\", ylab=\"displacement\") ````","title":"randomwalk1D"},{"location":"src/examples/randomwalk1D/#model-parameters","text":"L = 1000 space = ContinuousSpace((L,)) dt = 0.1 n = 10 nsteps = 600","title":"model parameters"},{"location":"src/examples/randomwalk1D/#abm-setup","text":"model = StandardABM(Microbe{1}, space, dt) foreach(_ -> add_agent!((0,), model), 1:n)","title":"abm setup"},{"location":"src/examples/randomwalk1D/#simulation","text":"adata = [:pos] adf, _ = run!(model, nsteps; adata)","title":"simulation"},{"location":"src/examples/randomwalk1D/#postprocessing","text":"traj = MicrobeAgents.unfold(vectorize_adf_measurement(adf,:pos), L) x = first.(traj) t = axes(x,1) .* dt","title":"postprocessing"},{"location":"src/examples/randomwalk1D/#visualization","text":"plot(t, x, leg=false, xlab=\"time\", ylab=\"displacement\") ````","title":"visualization"},{"location":"src/examples/randomwalk2D_motilepatterns/","text":"@meta EditURL = \"../../../examples/RandomWalks/randomwalk2D_motilepatterns.jl\" ````@example randomwalk2D_motilepatterns using MicrobeAgents using Distributions using Plots model parameters L = 500 space = ContinuousSpace((L,L)) dt = 0.1 nsteps = 600 abm setup model = StandardABM(Microbe{2}, space, dt) add bacteria with different motile properties ````@example randomwalk2D_motilepatterns add_agent!(model; motility=RunReverse(speed=[55]), rotational_diffusivity=0.2) add_agent!(model; motility=RunTumble(speed=Normal(30,6)), turn_rate=0.5) add_agent!(model; motility=RunReverseFlick(speed_backward=[6]), rotational_diffusivity=0.1) # simulation adata = [:pos] adf, _ = run!(model, nsteps; adata) # postprocessing traj = MicrobeAgents.unfold(vectorize_adf_measurement(adf,:pos), L) x = first.(traj) y = last.(traj) t = axes(x,1) .* dt # visualization plot(x, y, xlab=\"x\", ylab=\"y\", ratio=1, lab=[\"RunReverse\" \"RunTumble\" \"RunReverseFlick\"] )","title":"randomwalk2D motilepatterns"},{"location":"src/examples/randomwalk2D_motilepatterns/#model-parameters","text":"L = 500 space = ContinuousSpace((L,L)) dt = 0.1 nsteps = 600","title":"model parameters"},{"location":"src/examples/randomwalk2D_motilepatterns/#abm-setup","text":"model = StandardABM(Microbe{2}, space, dt) add bacteria with different motile properties ````@example randomwalk2D_motilepatterns add_agent!(model; motility=RunReverse(speed=[55]), rotational_diffusivity=0.2) add_agent!(model; motility=RunTumble(speed=Normal(30,6)), turn_rate=0.5) add_agent!(model; motility=RunReverseFlick(speed_backward=[6]), rotational_diffusivity=0.1) # simulation adata = [:pos] adf, _ = run!(model, nsteps; adata) # postprocessing traj = MicrobeAgents.unfold(vectorize_adf_measurement(adf,:pos), L) x = first.(traj) y = last.(traj) t = axes(x,1) .* dt # visualization plot(x, y, xlab=\"x\", ylab=\"y\", ratio=1, lab=[\"RunReverse\" \"RunTumble\" \"RunReverseFlick\"] )","title":"abm setup"},{"location":"src/examples/randomwalk3D/","text":"@meta EditURL = \"../../../examples/RandomWalks/randomwalk3D.jl\" ````@example randomwalk3D using MicrobeAgents using Distributions using Plots model parameters L = 500 space = ContinuousSpace((L,L,L)) dt = 0.1 nsteps = 600 abm setup model = StandardABM(Microbe{3}, space, dt) add bacteria with different motile properties ````@example randomwalk3D add_agent!(model; motility=RunReverse(speed=[55]), rotational_diffusivity=0.2) add_agent!(model; motility=RunTumble(speed=Normal(30,6)), turn_rate=0.5) add_agent!(model; motility=RunReverseFlick(speed_backward=[6]), rotational_diffusivity=0.1) # simulation adata = [:pos] adf, _ = run!(model, nsteps; adata) # postprocessing traj = MicrobeAgents.unfold(vectorize_adf_measurement(adf,:pos), L) x = first.(traj) y = map(s -> s[2], traj) z = last.(traj) t = axes(x,1) .* dt # visualization plot(x, y, z, xlab=\"x\", ylab=\"y\", zlab=\"z\", lw=2, ratio=1, lab=[\"RunReverse\" \"RunTumble\" \"RunReverseFlick\"] )","title":"randomwalk3D"},{"location":"src/examples/randomwalk3D/#model-parameters","text":"L = 500 space = ContinuousSpace((L,L,L)) dt = 0.1 nsteps = 600","title":"model parameters"},{"location":"src/examples/randomwalk3D/#abm-setup","text":"model = StandardABM(Microbe{3}, space, dt) add bacteria with different motile properties ````@example randomwalk3D add_agent!(model; motility=RunReverse(speed=[55]), rotational_diffusivity=0.2) add_agent!(model; motility=RunTumble(speed=Normal(30,6)), turn_rate=0.5) add_agent!(model; motility=RunReverseFlick(speed_backward=[6]), rotational_diffusivity=0.1) # simulation adata = [:pos] adf, _ = run!(model, nsteps; adata) # postprocessing traj = MicrobeAgents.unfold(vectorize_adf_measurement(adf,:pos), L) x = first.(traj) y = map(s -> s[2], traj) z = last.(traj) t = axes(x,1) .* dt # visualization plot(x, y, z, xlab=\"x\", ylab=\"y\", zlab=\"z\", lw=2, ratio=1, lab=[\"RunReverse\" \"RunTumble\" \"RunReverseFlick\"] )","title":"abm setup"}]}