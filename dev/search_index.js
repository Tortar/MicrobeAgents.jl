var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#Analysis","page":"API","title":"Data analysis","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"msd\nacf\ndriftvelocity_direction\ndriftvelocity_point\ndetect_turns\nrundurations\nmean_runduration\nmean_turnrate","category":"page"},{"location":"api/#MicrobeAgents.msd","page":"API","title":"MicrobeAgents.msd","text":"msd(adf, lags=1:last(adf.step)-1; L=Inf)\n\nEvaluate mean-squared displacement from an agent dataframe adf containing the position timeseries of agents (adf.pos). Parameter L defines the periodicity of the domain for unfolding; set L=Inf (default) if boundaries are not periodic.\n\n\n\n\n\nmsd(x, lags=1:size(x,1)-1)\n\nEvaluate the mean squared displacement of x at timelags lags. If lags is unspecified, all available timepoints are used (lag-0 excluded).\n\nx can be an AbstractVector or an AbstractMatrix. In the latter case, it is assumed that each column represents a distinct signal and each row a timepoint. The msd is then evaluated for each individual timeseries and the results are averaged together.\n\n\n\n\n\n","category":"function"},{"location":"api/#MicrobeAgents.acf","page":"API","title":"MicrobeAgents.acf","text":"acf(x, sym, lags=0:last(x.step)-1)\n\nEvaluate the autocorrelation function for quantity sym from dataframe x (x.sym) at timelags lags. If lags is unspecified, the acf is evaluated for all available timepoints.\n\n\n\n\n\nacf(x, lags=0:size(x,1)-1)\n\nEvaluate the autocorrelation function (acf) of a signal x at timelags lags. If lags is unspecified, the acf is evaluated for all available time points.\n\nThe signal x can be an AbstractVector or an AbstractMatrix. In the latter case, it is assumed that each column represents a distinct signal and each row a timepoint. The acf is then evaluated for each individual timeseries and the results are averaged together.\n\nThe result is not normalized. If f = acf(x), just evaluate f./f[1] to normalize it.\n\n\n\n\n\n","category":"function"},{"location":"api/#MicrobeAgents.driftvelocity_direction","page":"API","title":"MicrobeAgents.driftvelocity_direction","text":"driftvelocity_direction(adf, target; normalize=false)\n\nEvaluate the drift velocity of microbes along a direction target, extracting their velocities from the agent dataframe adf (requires :vel field).\n\nReturns a matrix of instantaneous drift velocities with size (nmicrobes, nsteps). By convention the drift velocity will be positive for motion along the target direction.\n\nIf normalize is set to true, drift velocities are normalized by the instantaneous speed of the microbe.\n\n\n\n\n\n","category":"function"},{"location":"api/#MicrobeAgents.driftvelocity_point","page":"API","title":"MicrobeAgents.driftvelocity_point","text":"driftvelocity_point(adf, target; normalize=false)\n\nEvaluate the drift velocity of microbes towards a point target, extracting their positions and velocities from the agent dataframe adf (requires the existence of :pos and :vel fields). Returns a matrix of instantaneous drift velocities with size (nmicrobes, nsteps). By convention the drift velocity will be positive for motion towards the target point.\n\nIf normalize is set to true, drift velocities are normalized by the instantaneous speed of the microbe.\n\n\n\n\n\n","category":"function"},{"location":"api/#MicrobeAgents.detect_turns","page":"API","title":"MicrobeAgents.detect_turns","text":"detect_turns(adf; threshold_angle=0.0)\n\nDetect reorientations in the microbe trajectories in adf. Requires adf to have a :vel field containing the unit-norm velocity vector. In order to be detected, a reorientation must be larger than the threshold_angle (in radians); the threshold defaults to 0.\n\nAlso works if adf is an AbstractMatrix, with unit velocity vectors for each microbe sorted by column, or if adf is an AbstractVector (unit velocity vectors for a single microbe).\n\n\n\n\n\n","category":"function"},{"location":"api/#MicrobeAgents.rundurations","page":"API","title":"MicrobeAgents.rundurations","text":"rundurations(adf, Δt; threshold_angle=0.0)\n\nEvaluate the duration of all runs observed during a simulation. The dataframe adf should contain the field :vel. Δt is the integration timestep of the simulation. threshold_angle defines the threshold (in radians) to define a reorientation. The function returns a vector of run durations for each microbe.\n\nAlso works if adf is an AbstractMatrix, with unit velocity vectors for each microbe sorted by column, or if adf is an AbstractVector (unit velocity vectors for a single microbe).\n\n\n\n\n\n","category":"function"},{"location":"api/#MicrobeAgents.mean_runduration","page":"API","title":"MicrobeAgents.mean_runduration","text":"mean_runduration(adf, Δt; threshold_angle=0.0)\n\nEvaluate the mean run duration sampled by the simulation. The dataframe adf should contain the field :vel. Δt is the integration timestep of the simulation. threshold_angle defines the threshold (in radians) to define a reorientation.\n\nAlso works if adf is an AbstractMatrix, with unit velocity vectors for each microbe sorted by column, or if adf is an AbstractVector (unit velocity vectors for a single microbe).\n\n\n\n\n\n","category":"function"},{"location":"api/#MicrobeAgents.mean_turnrate","page":"API","title":"MicrobeAgents.mean_turnrate","text":"mean_turnrate(adf, Δt; threshold_angle=0.0)\n\nEvaluate the mean turn rate sampled by the simulation. The dataframe adf should contain the field :vel. Δt is the integration timestep of the simulation. threshold_angle defines the threshold (in radians) to define a reorientation.\n\nAlso works if adf is an AbstractMatrix, with unit velocity vectors for each microbe sorted by column, or if adf is an AbstractVector (unit velocity vectors for a single microbe).\n\n\n\n\n\n","category":"function"},{"location":"randomwalks/#Random-walks","page":"Random walks","title":"Random walks","text":"","category":"section"},{"location":"randomwalks/","page":"Random walks","title":"Random walks","text":"Generating random walks with MicrobeAgents.jl is super-easy, and the walk properties can be fine-tuned to match all sorts of needs.","category":"page"},{"location":"randomwalks/","page":"Random walks","title":"Random walks","text":"By default, MicrobeAgents.jl produces random walks composed of runs at constant speed and arbitrary reorientations where the waiting times between such reorientations are i.i.d. random variables. In the absence of chemotaxis (or other behavioral responses that affect microbe motility), the generated random walks will display an exponential distribution of waiting times.","category":"page"},{"location":"randomwalks/#Random-Walk-in-D1","page":"Random walks","title":"Random Walk in D=1","text":"","category":"section"},{"location":"randomwalks/","page":"Random walks","title":"Random walks","text":"using MicrobeAgents\n\nL = 1000\nspace = ContinuousSpace((L,))\ndt = 0.1\nn = 10\nnsteps = 600\n\nmodel = UnremovableABM(Microbe{1}, space, dt)\nforeach(_ -> add_agent!((0,), model), 1:n)","category":"page"},{"location":"randomwalks/","page":"Random walks","title":"Random walks","text":"By default, UnremovableABM will create a periodic domain; this will allow us to mimic an \"infinite\" system. All the microbes have been initialized from position 0, without specifying any further property, so they will be initialized with a random velocity (either (+1,) or (-1,) in this 1D scenario), speed=30.0, and turn_rate=1.0. The motility is set by default to RunTumble(speed=[30.0]) but any other motile pattern in 1D would produce the same result; only speed is relevant here.","category":"page"},{"location":"randomwalks/","page":"Random walks","title":"Random walks","text":"To run the simulation while collecting the bacterial positions at each step we will then run","category":"page"},{"location":"randomwalks/","page":"Random walks","title":"Random walks","text":"adata = [:pos]\nadf, _ = run!(model, nsteps; adata)","category":"page"},{"location":"randomwalks/","page":"Random walks","title":"Random walks","text":"The dataframe adf can now be turned into a matrix of positions, with each row representing a different timepoint, and each column a different microbe. And since we used periodic boundary conditions, the trajectories can be unfolded","category":"page"},{"location":"randomwalks/","page":"Random walks","title":"Random walks","text":"trajectories = MicrobeAgents.unfold(vectorize_adf_measurement(adf, :pos), L)","category":"page"},{"location":"randomwalks/","page":"Random walks","title":"Random walks","text":"trajectories is now a Matrix{Tuple{Float64}}. To obtain the x positions for plotting we can call","category":"page"},{"location":"randomwalks/","page":"Random walks","title":"Random walks","text":"x = first.(trajectories)\nt = axes(x,1) .* dt\nplot(t,x,lab=false,xlab=\"time\",ylab=\"displacement\")","category":"page"},{"location":"randomwalks/#Random-walks-with-different-motile-patterns-in-D2","page":"Random walks","title":"Random walks with different motile patterns in D=2","text":"","category":"section"},{"location":"randomwalks/","page":"Random walks","title":"Random walks","text":"The procedure to generate a random walk in higher dimensions is exactly the same","category":"page"},{"location":"randomwalks/","page":"Random walks","title":"Random walks","text":"L = 500\nspace = ContinuousSpace((L,L))\ndt = 0.1\nnsteps = 600\n\nmodel = UnremovableABM(Microbe{2}, space, dt)","category":"page"},{"location":"randomwalks/","page":"Random walks","title":"Random walks","text":"But we can now add bacteria with different motility patterns (we import Distributions.jl to use a Normal distribution for the speed of one of our microbes)","category":"page"},{"location":"randomwalks/","page":"Random walks","title":"Random walks","text":"using Distributions\nadd_agent!(model; motility=RunReverse(speed_forward=[55]), rotational_diffusivity=0.2)\nadd_agent!(model; motility=RunTumble(speed=Normal(30,6)), turn_rate=0.5)\nadd_agent!(model; motility=RunReverseFlick(speed_backward=[6]), rotational_diffusivity=0.1)","category":"page"},{"location":"randomwalks/","page":"Random walks","title":"Random walks","text":"and then we run and visualize as before","category":"page"},{"location":"randomwalks/","page":"Random walks","title":"Random walks","text":"adata = [:pos]\nadf, _ = run!(model, nsteps; adata)\n\n# postprocessing\ntraj = MicrobeAgents.unfold(vectorize_adf_measurement(adf,:pos), L)\nx = first.(traj)\ny = last.(traj)\nt = axes(x,1) .* dt\nplot(x, y, xlab=\"x\", ylab=\"y\", ratio=1,\n    lab=[\"RunReverse\" \"RunTumble\" \"RunReverseFlick\"]\n)","category":"page"},{"location":"randomwalks/","page":"Random walks","title":"Random walks","text":"(Image: Two-dimensional random walks with different motility patterns)","category":"page"},{"location":"validation/#Validation","page":"Validation","title":"Validation","text":"","category":"section"},{"location":"validation/#Run-Time-Distribution","page":"Validation","title":"Run Time Distribution","text":"","category":"section"},{"location":"validation/","page":"Validation","title":"Validation","text":"(examples/Analysis/run_distribution.jl) Run times should be exponentially distributed, with tau being the inverse of the average turn rate.","category":"page"},{"location":"validation/","page":"Validation","title":"Validation","text":"(Image: Exponential distribution of run times)","category":"page"},{"location":"validation/","page":"Validation","title":"Validation","text":"The smaller the timestep Delta t compared to the average run length tau, the better the agreement between numerical results and theory. A ratio tau  Delta t sim 10 is typically sufficient to have a reasonable agreement.","category":"page"},{"location":"validation/#Velocity-Autocorrelation-Function","page":"Validation","title":"Velocity Autocorrelation Function","text":"","category":"section"},{"location":"validation/","page":"Validation","title":"Validation","text":"Velocity autocorrelation functions for the three motility patterns should obey the following equations (Taktikos et al. PLoS ONE 2012): `` \\phi(t) = \\begin{cases}   \\text{exp}(-t/\\tau), & \\text{run-tumble} \\\n  \\text{exp}(-2t/\\tau), & \\text{run-reverse} \\\n  (1-t/2\\tau)\\text{exp}(-t/\\tau), & \\text{run-reverse-flick} \\end{cases} `` (assuming no rotational diffusion, and that forward and backward mode have identical timescales for the run-reverse-flick swimmer).","category":"page"},{"location":"validation/","page":"Validation","title":"Validation","text":"(Image: Velocity autocorrelation functions for run-tumble, run-reverse, run-reverse-flick)","category":"page"},{"location":"validation/#Mean-Squared-Displacement","page":"Validation","title":"Mean Squared Displacement","text":"","category":"section"},{"location":"validation/","page":"Validation","title":"Validation","text":"The mean squared displacement (MSD) for a run-tumble swimmer with average turn angle theta (and without rotational diffusion) should obey the following equation (Taktikos et al. PLoS ONE 2012):","category":"page"},{"location":"validation/","page":"Validation","title":"Validation","text":"textMSD(t) = 2v^2tildetau^2 (ttildetau - 1 + e^-ttildetau) where tildetau = tau(1-costheta).","category":"page"},{"location":"validation/","page":"Validation","title":"Validation","text":"(Image: MSD of run-tumble motility with varying turn angle distributions)","category":"page"},{"location":"chemotaxis/#Chemotaxis","page":"Chemotaxis","title":"Chemotaxis","text":"","category":"section"},{"location":"chemotaxis/#Linear-concentration-ramp","page":"Chemotaxis","title":"Linear concentration ramp","text":"","category":"section"},{"location":"chemotaxis/","page":"Chemotaxis","title":"Chemotaxis","text":"As a first step into the world of chemotaxis, we will reproduce an in-silico version of a classical laboratory assay: a linear concentration ramp in a rectangular channel. We will use the BrownBerg model.","category":"page"},{"location":"chemotaxis/","page":"Chemotaxis","title":"Chemotaxis","text":"To define concentration profiles, MicrobeAgents.jl expects three functions: concentration_field, concentration_gradient and concentration_time_derivative, all of which must have a method with signature (pos,model), i.e. they take as input a microbe position and the ABM object. In this example the field is static, so we won't define a time derivative.","category":"page"},{"location":"chemotaxis/","page":"Chemotaxis","title":"Chemotaxis","text":"using MicrobeAgents\n\n@inline function concentration_field(pos, model)\n    C₀ = model.C₀\n    C₁ = model.C₁\n    Lx = first(model.space.extent)\n    concentration_field(pos,Lx,C₀,C₁)\nend\n@inline concentration_field(pos,Lx,C₀,C₁) = C₀ + (C₁-C₀)*pos[1]/Lx\n\n@inline function concentration_gradient(pos, model)\n    C₀ = model.C₀\n    C₁ = model.C₁\n    Lx = first(model.space.extent)\n    concentration_gradient(pos,Lx,C₀,C₁)\nend\n@inline concentration_gradient(pos,Lx,C₀,C₁) = ntuple(i->i==1 ? (C₁-C₀)/Lx : 0.0, length(pos))","category":"page"},{"location":"chemotaxis/","page":"Chemotaxis","title":"Chemotaxis","text":"The quantities C₀ and C₁ represent the concentration values at left (x=0) and right (x=L) edges of the channel. Notice that concentration_gradient returns a Tuple with the same size as pos, not just a Number. This is required since the gradient is a vector quantity.","category":"page"},{"location":"chemotaxis/","page":"Chemotaxis","title":"Chemotaxis","text":"We can set up the ABM as usual, but we will need to supply :concentration_field and :concentration_gradient to the properties container, as well as :C₀ and :C₁. Then we can run the simulation and make a nice plot.","category":"page"},{"location":"chemotaxis/","page":"Chemotaxis","title":"Chemotaxis","text":"Lx, Ly = 3000, 1500\nextent = (Lx, Ly)\nperiodic = false\nspace = ContinuousSpace(extent; periodic)\nΔt = 0.1 # timestep (s)\nT = 120 # simulation time (s)\nnsteps = round(Int, T/Δt)\nn = 100\n\nC₀, C₁ = 0.0, 20.0 # μM\nproperties = Dict(\n    :C₀ => C₀,\n    :C₁ => C₁,\n    :concentration_field => concentration_field,\n    :concentration_gradient => concentration_gradient\n)\nmodel = UnremovableABM(BrownBerg{2}, space, Δt; periodic, properties)\nfor i in 1:n\n    add_agent!(model)\nend\n\nadata = [:pos]\nadf, mdf = run!(model, nsteps; adata)\n\ntraj = vectorize_adf_measurement(adf, :pos)\nx = first.(traj)\ny = last.(traj)\n\nts = unique(adf.step) .* Δt\nlw = eachindex(ts) ./ length(ts) .* 3\nxmesh = range(0,Lx,length=100)\nymesh = range(0,Ly,length=100)\nxn = @view x[:,1:10]\nyn = @view y[:,1:10]\nc = concentration_field.(Iterators.product(xmesh,ymesh),Lx,C₀,C₁)\nheatmap(xmesh, ymesh, c', cbar=false, ratio=1, axis=false, c=:bone)\nplot!(xn, yn, lab=false, lw=lw, lc=(1:n)')\nscatter!(xn[end,:], yn[end,:], lab=false, m=:c, mc=1:n, msw=0.5, ms=8)","category":"page"},{"location":"chemotaxis/","page":"Chemotaxis","title":"Chemotaxis","text":"(Image: Drift of chemotactic bacteria in a linear concentration ramp)","category":"page"},{"location":"#MicrobeAgents.jl","page":"Home","title":"MicrobeAgents.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"MicrobeAgents.jl is a Julia framework for agent-based simulations of bacterial motility and chemotaxis, built on the amazing Agents.jl.","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Runs in 1, 2 and 3 spatial dimensions.\nProvides various motility patterns (Run-Tumble, Run-Reverse, Run-Reverse-Flick), all with customizable speed and turn angle distributions.\nVarious models of bacterial chemotaxis (Brown & Berg, PNAS 1974; Celani & Vergassola, PNAS 2010; Xie et al, Biophys J 2014; Brumley et al, PNAS 2019).\nFast analysis routines for common quantities of interest (run statistics, MSD, autocorrelation functions, drift velocity).","category":"page"},{"location":"#Limitations-(some-may-be-temporary,-others-may-be-not)","page":"Home","title":"Limitations (some may be temporary, others may be not)","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Only continuous space models are supported\nReorientations are always assumed to be instantaneous; this approximation is really only reasonable when the integration timestep is above 50ms.\nIntegration timestep also sets the sensory integration timescale in chemotactic models.","category":"page"},{"location":"#What-this-package-is-not-good-for","page":"Home","title":"What this package is not good for","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Although, in principle, you can add arbitrary layers of complexity on top the provided interface, there are a few things for which this package is not a recommended choice.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Hydrodynamic interactions.\nAtomistic representation of biochemical pathways.","category":"page"},{"location":"#Contribute","page":"Home","title":"Contribute","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package is still in an early stage of intense development. If you would like to have support for your favorite model of chemotaxis, or need some specific features to be implemented, please open an issue. I'll try to satisfy as many requests as possible.","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you would like to take a more active part in the development, please consider contacting me directly at rfoffi@ethz.ch.","category":"page"},{"location":"#Citation","page":"Home","title":"Citation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you use this package in work that leads to a publication, please cite the GitHub repository:","category":"page"},{"location":"","page":"Home","title":"Home","text":"@misc{Foffi2023,\n    author = {Foffi, R.},\n    title = {MicrobeAgents.jl},\n    year = {2023},\n    publisher = {GitHub},\n    journal = {GitHub repository},\n    howpublished = {\\url{https://github.com/mastrof/MicrobeAgents.jl}}\n}","category":"page"},{"location":"#Acknowledgements","page":"Home","title":"Acknowledgements","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This project has received funding from the European Union's Horizon 2020 research and innovation programme under the Marie Skłodowska-Curie grant agreement No 955910.","category":"page"},{"location":"firststeps/#First-steps","page":"First steps","title":"First steps","text":"","category":"section"},{"location":"firststeps/#Structure","page":"First steps","title":"Structure","text":"","category":"section"},{"location":"firststeps/","page":"First steps","title":"First steps","text":"An AgentBasedModel object embeds all the properties of the system to be simulated and maps unique IDs to microbe instances. During the simulation, the model is evolved in discrete time steps, with each microbe's \"state\" being updated according to specified rules. Standard rules for motion, reorientations and chemotaxis are available by default, but custom behaviors can be implemented via user-defined functions.","category":"page"},{"location":"firststeps/","page":"First steps","title":"First steps","text":"The typical workflow to run a simulation in MicrobeAgents.jl goes as follows:","category":"page"},{"location":"firststeps/","page":"First steps","title":"First steps","text":"Define the size and properties of the space in which the microbes will move.\nChoose an appropriate microbe type to represent the desired behavior, or define a new one.\nInitialize an AgentBasedModel object with the desired space, microbe type, integration time step, and any extra property needed for the simulation.\nPopulated the ABM with microbe instances.\nRun the model (defining custom stepping functions if required) and collect data.","category":"page"},{"location":"firststeps/","page":"First steps","title":"First steps","text":"MicrobeAgents.jl re-exports and extends various function from Agents.jl in order to work as a standalone, but it is generally recommended to use it in combination with Agents.jl for extra goodies.","category":"page"},{"location":"firststeps/#Space","page":"First steps","title":"Space","text":"","category":"section"},{"location":"firststeps/","page":"First steps","title":"First steps","text":"MicrobAgents.jl only supports continuous spaces with dimensions 1, 2 or 3. Spaces can be created with the ContinuousSpace function (reexported from Agents.jl). The extent of the space must be given as a tuple, and periodicity is set with the periodic kwarg (defaults to true).","category":"page"},{"location":"firststeps/","page":"First steps","title":"First steps","text":"# one-dimensional periodic space\nextent = (1.0,)\nContinuousSpace(extent)\n\n# two-dimensional non-periodic space\nextent = (1.0, 2.0)\nContinuousSpace(extent; periodic=false)","category":"page"},{"location":"firststeps/#Microbes","page":"First steps","title":"Microbes","text":"","category":"section"},{"location":"firststeps/","page":"First steps","title":"First steps","text":"Microbes are represented by subtypes of the AbstractMicrobe type, which is in turn a subtype of AbstractAgent introduced by Agents.jl","category":"page"},{"location":"firststeps/","page":"First steps","title":"First steps","text":"AbstractMicrobe","category":"page"},{"location":"firststeps/#MicrobeAgents.AbstractMicrobe","page":"First steps","title":"MicrobeAgents.AbstractMicrobe","text":"AbstractMicrobe{D} <: AbstractAgent where {D<:Integer}\n\nAll microbe types in MicrobeAgents.jl simulations must be instances of user-defined types that are subtypes of AbstractMicrobe.     YourMicrobeType{D} <: AbstractMicrobe{D} The parameter D defines the dimensionality of the space in which the microbe type lives (1, 2 and 3 are supported).\n\nAll microbe types must have at least the following fields:\n\nid::Int id of the microbe (used internally by Agents.jl)\npos::NTuple{D,Float64} position of the microbe\nvel::NTuple{D,Float64} velocity of the microbe\nmotility::AbstractMotility motile pattern of the microbe\nturn_rate::Real average reorientation rate of the microbe\nrotational_diffusivity::Real coefficient of brownian rotational diffusion\nradius::Real equivalent spherical radius of the microbe\nstate::Real generic variable for a scalar internal state\n\n\n\n\n\n","category":"type"},{"location":"firststeps/","page":"First steps","title":"First steps","text":"MicrobeAgents provides different AbstractMicrobe subtypes representing different models of bacterial behavior from the literature.","category":"page"},{"location":"firststeps/","page":"First steps","title":"First steps","text":"A basic type, which is typically sufficient for simple motility simulations and does not include chemotaxis, is the Microbe type.","category":"page"},{"location":"firststeps/","page":"First steps","title":"First steps","text":"Microbe","category":"page"},{"location":"firststeps/#MicrobeAgents.Microbe","page":"First steps","title":"MicrobeAgents.Microbe","text":"Microbe{D} <: AbstractMicrobe{D}\n\nBasic microbe type for simple simulations.\n\nDefault parameters:\n\nid::Int = rand(1:typemax(Int)) identifier used internally by Agents.jl\npos::NTuple{D,Float64} = ntuple(zero,D) position\nmotility = RunTumble() motile pattern\nvel::NTuple{D,Float64} = rand_vel(D) unit velocity vector\nspeed::Float64 = rand_speed(motility) magnitude of velocity vector\nturn_rate::Float64 = 1.0 frequency of reorientations\nrotational_diffusivity::Real coefficient of brownian rotational diffusion\nradius::Float64 = 0.0 equivalent spherical radius of the microbe\nstate::Float64 = 0.0 generic variable for a scalar internal state\n\n\n\n\n\n","category":"type"},{"location":"firststeps/","page":"First steps","title":"First steps","text":"The dimensionality of Microbe must always be specified on creation. All the fields are instead optional, and if not specified will be assigned default values.","category":"page"},{"location":"firststeps/","page":"First steps","title":"First steps","text":"To create a Microbe living in a 1-dimensional space, with default parameters (RunTumble motility, average turn rate nu=1s^-1, and no rotational diffusivity), it is therefore sufficient to run","category":"page"},{"location":"firststeps/","page":"First steps","title":"First steps","text":"Microbe{1}()","category":"page"},{"location":"firststeps/","page":"First steps","title":"First steps","text":"Similarly, for two and three dimensions:","category":"page"},{"location":"firststeps/","page":"First steps","title":"First steps","text":"Microbe{2}()\nMicrobe{3}()","category":"page"},{"location":"firststeps/","page":"First steps","title":"First steps","text":"Any custom parameter can be set via kwargs:","category":"page"},{"location":"firststeps/","page":"First steps","title":"First steps","text":"Microbe{3}(\n    turn_rate = 0.6,\n    rotational_diffusivity = 0.1\n)","category":"page"},{"location":"firststeps/","page":"First steps","title":"First steps","text":"All the other subtypes of AbstractMicrobe work in a similar way, although they will have distinct default values and extra fields. Default values are typically assigned following the original implementation in the literature.","category":"page"},{"location":"firststeps/","page":"First steps","title":"First steps","text":"BrownBerg\nBrumley\nCelani\nXie","category":"page"},{"location":"firststeps/#MicrobeAgents.BrownBerg","page":"First steps","title":"MicrobeAgents.BrownBerg","text":"BrownBerg{D} <: AbstractMicrobe{D}\n\nModel of chemotactic E.coli from 'Brown and Berg (1974) PNAS'\n\nDefault parameters:\n\nmotility = RunTumble()\nturn_rate = 1.49 Hz frequency of reorientations\nrotational_diffusivity = 0.035 rad²/s coefficient of brownian rotational diffusion\nradius = 0.5 μm equivalent spherical radius of the microbe\nstate = 0.0 corresponds to 'weighted dPb/dt' in the paper\ngain = 660 s\nreceptor_binding_constant = 100 μM\nmemory = 1 s\n\n\n\n\n\n","category":"type"},{"location":"firststeps/#MicrobeAgents.Brumley","page":"First steps","title":"MicrobeAgents.Brumley","text":"Brumley{D} <: AbstractMicrobe{D}\n\nModel of chemotactic bacterium from 'Brumley et al. (2019) PNAS'. The model is optimized for simulation of marine bacteria and accounts for the presence of (gaussian) sensing noise in the chemotactic pathway.\n\nDefault parameters:\n\nmotility = RunReverseFlick(speed_forward = [46.5])\nturn_rate = 2.22 Hz → '1/τ₀'\nstate = 0.0 → 'S'\nrotational_diffusivity = 0.035 rad²/s\nmemory = 1.3 s → 'τₘ'\ngain_receptor = 50.0 μM⁻¹ → 'κ'\ngain = 50.0 → 'Γ'\nchemotactic_precision = 6.0 → 'Π'\nradius = 0.5 μm → 'a'\n\n\n\n\n\n","category":"type"},{"location":"firststeps/#MicrobeAgents.Celani","page":"First steps","title":"MicrobeAgents.Celani","text":"Celani{D} <: AbstractMicrobe{D}\n\nModel of chemotactic bacterium using the response kernel from 'Celani and Vergassola (2010) PNAS', extracted from experiments on E. coli.\n\nSensing noise (not present in the original model) is customarily introduced through the molecular counting noise formula by Berg and Purcell, and can be tuned through a chemotactic_precision factor inspired by 'Brumley et al. (2019) PNAS' (defaults to 0, i.e. no noise).\n\nDefault parameters:\n\nmotility = RunTumble(speed = [30.0])\nturn_rate = 1.49 Hz\nstate = 0\nrotational_diffusivity = 0.26 rad²/s\ngain = 50.0\nmemory = 1 s\nradius = 0.5 μm\n\n\n\n\n\n","category":"type"},{"location":"firststeps/#MicrobeAgents.Xie","page":"First steps","title":"MicrobeAgents.Xie","text":"Xie{D} <: AbstractMicrobe{D}\n\nModel of chemotactic bacterium adapted from 'Xie et al. (2019) Biophys J'. The model is developed based on experimental measurements of the chemotactic response function in the marine bacterium V. alginolyticus. The peculiarity of the model is the presence of distinct parameters for the forward and backward swimming states.\n\nSensing noise (not present in the original model) is customarily introduced through the molecular counting noise formula by Berg and Purcell, and can be tuned through a chemotactic_precision factor inspired by 'Brumley et al. (2019) PNAS' (defaults to 0, i.e. no noise).\n\nDefault parameters:\n\nmotility = RunReverseFlick(speed_forward = [46.5])\nturn_rate_forward = 2.3 Hz\nturn_rate_backward = 1.9 Hz\nstate = 0.0 s\nstate_m = 0.0 s\nstate_z = 0.0 s\nrotational_diffusivity = 0.26 rad²/s\nadaptation_time_m = 1.29 s\nadaptation_time_z = 0.28 s\ngain_forward = 2.7 1/s\ngain_backward = 1.6 1/s\nbinding_affinity = 0.39 μM\nchemotactic_precision = 0.0\nradius = 0.5 μm\n\n\n\n\n\n","category":"type"},{"location":"firststeps/#Creating-a-model","page":"First steps","title":"Creating a model","text":"","category":"section"},{"location":"firststeps/","page":"First steps","title":"First steps","text":"MicrobeAgents.jl exploits the AgentBasedModel interface from Agents.jl. While the standard Agents.jl syntax will always work, it is typically more convenient to use the method extensions provided by MicrobeAgents.jl, which also includes some default parameters required by the simulations. Both StandardABM and UnremovableABM are supported. Whenever removal of microbes during the simulation is not needed, UnremovableABM is the recommended choice.","category":"page"},{"location":"firststeps/","page":"First steps","title":"First steps","text":"UnremovableABM\nStandardABM","category":"page"},{"location":"firststeps/#Agents.UnremovableABM","page":"First steps","title":"Agents.UnremovableABM","text":"UnremovableABM(MicrobeType, space, timestep; kwargs...)\n\nExtension of the Agents.UnremovableABM method for microbe types. Implementation of AgentBasedModel where agents can only be added but not removed. See Agents.AgentBasedModel for detailed information on the keyword arguments.\n\nArguments\n\nMicrobeType: subtype of AbstractMicrobe{D}, with explicitly specified dimensionality D. A list of available options can be obtained by running subtypes(AbstractMicrobe).\nspace: a ContinuousSpace{D} with the same dimensionality D as MicrobeType which specifies the spatial properties of the simulation domain.\ntimestep: the integration timestep of the simulation.\n\nKeywords\n\nproperties: additional container of data to specify model-level properties. MicrobeAgents.jl includes a set of default properties (detailed at the end).\nscheduler = Schedulers.fastest\nrng = Random.default_rng()\nspacing = minimum(extent)/20\nwarn = true\n\nDefault properties\n\nWhen a model is created, a default set of properties is included in the model (MicrobeAgents.default_ABM_properties):\n\nDEFAULT_ABM_PROPERTIES = Dict(\n    :t => 0, # counter for timekeeping\n    :concentration_field => (pos,model) -> 0.0,\n    :concentration_gradient => (pos,model) -> zero.(pos),\n    :concentration_time_derivative => (pos,model) -> 0.0,\n    # required by models of chemotaxis, default value is glutamate diffusivity\n    :compound_diffusivity => 608.0,\n    # model stepper, by default only keeps time\n    :update! => tick!\n)\n\nBy including these default properties, we make sure that all the chemotaxis models will work even without extra user intervention. All these properties can be overwritten by simply passing an equivalent key to the properties dictionary when creating the model.\n\n\n\n\n\n","category":"type"},{"location":"firststeps/#Agents.StandardABM","page":"First steps","title":"Agents.StandardABM","text":"StandardABM(MicrobeType, space, timestep; kwargs...)\n\nExtension of the Agents.StandardABM method for microbe types. Implementation of AgentBasedModel where agents can be added and removed at any time. If agents removal is not required, it is recommended to use UnremovableABM for better performance. See Agents.AgentBasedModel for detailed information on the keyword arguments.\n\nArguments\n\nMicrobeType: subtype of AbstractMicrobe{D}, with explicitly specified dimensionality D. A list of available options can be obtained by running subtypes(AbstractMicrobe).\nspace: a ContinuousSpace{D} with the same dimensionality D as MicrobeType which specifies the spatial properties of the simulation domain.\ntimestep: the integration timestep of the simulation.\n\nKeywords\n\nproperties: additional container of data to specify model-level properties. MicrobeAgents.jl includes a set of default properties (detailed at the end).\nscheduler = Schedulers.fastest\nrng = Random.default_rng()\nwarn = true\n\nDefault properties\n\nWhen a model is created, a default set of properties is included in the model (MicrobeAgents.default_ABM_properties):\n\nDEFAULT_ABM_PROPERTIES = Dict(\n    :t => 0, # counter for timekeeping\n    :concentration_field => (pos,model) -> 0.0,\n    :concentration_gradient => (pos,model) -> zero.(pos),\n    :concentration_time_derivative => (pos,model) -> 0.0,\n    # required by models of chemotaxis, default value is glutamate diffusivity\n    :compound_diffusivity => 608.0,\n    # model stepper, by default only keeps time\n    :update! => tick!\n)\n\nBy including these default properties, we make sure that all the chemotaxis models will work even without extra user intervention. All these properties can be overwritten by simply passing an equivalent key to the properties dictionary when creating the model.\n\n\n\n\n\n","category":"type"},{"location":"firststeps/","page":"First steps","title":"First steps","text":"To create a simple model, we just need to choose a microbe type, the size of the simulation domain and the integration timestep. The properties of the simulation domain are wrapped in the ContinuousSpace object.","category":"page"},{"location":"firststeps/","page":"First steps","title":"First steps","text":"extent = (1000.0, 500.0) # size of 2D simulation domain\nspace = ContinuousSpace(extent)\ndt = 0.1 # integration timestep\nmodel = UnremovableABM(Microbe{2}, space, dt)","category":"page"},{"location":"firststeps/","page":"First steps","title":"First steps","text":"Now bacteria can be added with the add_agent! function.","category":"page"},{"location":"firststeps/","page":"First steps","title":"First steps","text":"add_agent!","category":"page"},{"location":"firststeps/#Agents.add_agent!","page":"First steps","title":"Agents.add_agent!","text":"add_agent!([pos,] [MicrobeType,] model; kwargs...)\n\nMicrobeAgents extension of Agents.add_agent!. Creates and adds a new microbe to model, using the constructor of the agent type of the model. If model accepts mixed agent types, then MicrobeType must be specified. If not specified, pos will be assigned randomly in the model domain.\n\nKeywords can be used to specify default values to pass to the microbe constructor, otherwise default values from the constructor will be used. If unspecified, the function also generates a random velocity vector.\n\n\n\n\n\n","category":"function"},{"location":"firststeps/","page":"First steps","title":"First steps","text":"We need not specify anything if we want the microbe to be added at a random position with the default values from the constructor.","category":"page"},{"location":"firststeps/","page":"First steps","title":"First steps","text":"add_agent!(model)","category":"page"},{"location":"firststeps/","page":"First steps","title":"First steps","text":"The microbe will be now accessible as model[1].","category":"page"},{"location":"firststeps/#Running-a-model","page":"First steps","title":"Running a model","text":"","category":"section"},{"location":"firststeps/","page":"First steps","title":"First steps","text":"After the model has been created and populated with the desired number of microbes, we are ready to run the simulation. We just need to specify how many steps we want to simulate and what data to collect during the run:","category":"page"},{"location":"firststeps/","page":"First steps","title":"First steps","text":"nsteps = 100\nadf, mdf = run!(model, nsteps; adata=[:pos])","category":"page"},{"location":"firststeps/","page":"First steps","title":"First steps","text":"run! will return two dataframes, one for the agent-level data (adf) and one for the model-level data (mdf, which in this case will be empty). This way, we have produced our first random walk. Since adf.pos is a vector of tuples, we first have to unpack the x and y values and then we are ready to plot our trajectory.","category":"page"},{"location":"firststeps/","page":"First steps","title":"First steps","text":"using Plots\nx = first.(adf.pos)\ny = last.(adf.pos)\nplot(x, y)","category":"page"},{"location":"firststeps/","page":"First steps","title":"First steps","text":"Notice that we did not specify at all how the timestepping is performed. MicrobAgents.jl implements a default timestepper which is applied to all AbstractMicrobe instances, which takes care of motion, rotational diffusion and reorientations. Each subtype is then equipped with its own affect! and turnrate functions (explained later) which determine extra behavioral features (such as chemotaxis).","category":"page"},{"location":"firststeps/","page":"First steps","title":"First steps","text":"If different behavior is desired, the integration can be customized by passing custom timestepping functions to run!:","category":"page"},{"location":"firststeps/","page":"First steps","title":"First steps","text":"run!(model, my_agent_step!, my_model_step!, nsteps)","category":"page"},{"location":"firststeps/#Motility-patterns","page":"First steps","title":"Motility patterns","text":"","category":"section"},{"location":"firststeps/","page":"First steps","title":"First steps","text":"In MicrobeAgents.jl, motility patterns are represented as instances of AbstractMotility. In particular, currently available patterns are distinguished into two further categories: AbstractMotilityOneStep or AbstractMotilityTwoStep.","category":"page"},{"location":"firststeps/","page":"First steps","title":"First steps","text":"AbstractMotilityOneStep\nAbstractMotilityTwoStep","category":"page"},{"location":"firststeps/#MicrobeAgents.AbstractMotilityOneStep","page":"First steps","title":"MicrobeAgents.AbstractMotilityOneStep","text":"AbstractMotilityOneStep\n\nOne-step motility patterns (RunTumble). Subtypes have the following fields:\n\nspeed: distribution of microbe speed, new values extracted after each turn\npolar: distribution of polar angles\nazimuthal: distribution azimuthal angles\n\nFor 2-dimensional microbe types, only polar defines reorientations and azimuthal is ignored.\n\nNew one-step motility patterns can be created as\n\nMicrobeAgents.@motility NewMotilityType MotilityOneStep AbstractMotilityOneStep begin\n    # some extra fields if needed\nend\n\nThe necessary fields and subtyping will be added automatically, only new extra fields need to be specified in the definition. If default values have to be specified, a constructor needs to be defined explicitly.\n\n\n\n\n\n","category":"type"},{"location":"firststeps/#MicrobeAgents.AbstractMotilityTwoStep","page":"First steps","title":"MicrobeAgents.AbstractMotilityTwoStep","text":"AbstractMotilityTwoStep\n\nTwo-step motility patterns (RunReverse and RunReverseFlick), with different properties between forward and backward state of motion. Subtypes have the following fields:\n\nspeed_forward: distribution of microbe speed, new values extracted after each turn\npolar_forward: distribution of in-plane reorientations for motile state fw\nazimuthal_forward: distribution of out-of-plane reorientations for motile state fw\nspeed_backward: distribution of microbe speed, new values extracted after each turn\npolar_backward: distribution of in-plane reorientations for motile state bw\nazimuthal_backward: distribution of out-of-plane reorientations for motile state bw\nmotile_state: defines current motile state (e.g. Forward or Backward for a TwoState)\n\nFor 2-dimensional microbe types, only polar distributions define reorientations while azimuthal ones are ignored.\n\nNew two-step motility patterns can be created as\n\nMicrobeAgents.@motility NewMotilityType MotilityTwoStep AbstractMotilityTwoStep begin\n    # some extra fields if needed\nend\n\nThe necessary fields and subtyping will be added automatically, only new extra fields need to be specified in the definition. If default values have to be specified, a constructor needs to be defined explicitly.\n\n\n\n\n\n","category":"type"},{"location":"firststeps/","page":"First steps","title":"First steps","text":"One-step motility pattern are characterized by a single swimming stage. Two-step motility patterns instead have two stages which can have distinct properties; these two stages are referred to as \"forward\" and \"backward\" but can really represent anything.","category":"page"},{"location":"firststeps/","page":"First steps","title":"First steps","text":"MicrobeAgents.jl defines three standard motility patterns:","category":"page"},{"location":"firststeps/","page":"First steps","title":"First steps","text":"RunTumble()\nRunReverse()\nRunReverseFlick()","category":"page"},{"location":"firststeps/#MicrobeAgents.RunTumble-Tuple{}","page":"First steps","title":"MicrobeAgents.RunTumble","text":"RunTumble(; speed=(30.0,), polar=Uniform(-π,π), azimuthal=Arccos())\n\nRun-tumble motility. The kwargs speed, polar and azimuthal must be sampleable objects (ranges, arrays, tuples, distributions...), not scalars.\n\nWith default values, the reorientations are uniform on the sphere.\n\n\n\n\n\n","category":"method"},{"location":"firststeps/#MicrobeAgents.RunReverse-Tuple{}","page":"First steps","title":"MicrobeAgents.RunReverse","text":"RunReverse(;\n    speed_forward = (30.0,),\n    polar_forward = (π,),\n    azimuthal_forward = Arccos(),\n    speed_backward = speed_forward,\n    polar_backward = polar_forward,\n    azimuthal_backward = azimuthal_forward\n)\n\nRun-reverse motility, with possibility to have different properties between the forward (run) and backward (reverse) stages. All the fields must be sampleable objects (ranges, arrays, tuples, distributions...), not scalars.\n\nWith default values, reorientations are always perfect reversals and the speed is identical between forward and backward runs.\n\n\n\n\n\n","category":"method"},{"location":"firststeps/#MicrobeAgents.RunReverseFlick-Tuple{}","page":"First steps","title":"MicrobeAgents.RunReverseFlick","text":"RunReverseFlick(;\n    speed_forward = (30.0,),\n    polar_forward = (π,),\n    azimuthal_forward = Arccos(),\n    speed_backward = speed_forward,\n    polar_backward = (-π/2, π/2),\n    azimuthal_backward = azimuthal_forward\n)\n\nRun-reverse-flick motility, with possibility to have different properties between the forward (run) and backward (reverse) stages. All the fields must be sampleable objects (ranges, arrays, tuples, distributions...), not scalars.\n\nWith default values, reorientations after forward runs are perfect reversals, while reorientations after backward runs are uniformly distributed on the circle normal to the run direction; speed is identical between forward and backward runs.\n\n\n\n\n\n","category":"method"},{"location":"firststeps/","page":"First steps","title":"First steps","text":"The default values provided by the constructors always consider a constant swimming speed of 30 (micron/s) and \"ideal\" turn-angle distributions (isotropic for tumbles, perfect 180 and 90 degree reorientations for reverse and flicks). For more accurate simulation where the reorientation statistics of the microbes is important, appropriate distributions should be specified; the constructors will accept any object that can be sampled via rand().","category":"page"}]
}
