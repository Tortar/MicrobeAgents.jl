var documenterSearchIndex = {"docs":
[{"location":"validation/run_distribution/","page":"Run-length distribution","title":"Run-length distribution","text":"EditURL = \"../../../examples/Validation/run_distribution.jl\"","category":"page"},{"location":"validation/run_distribution/#Run-length-distribution","page":"Run-length distribution","title":"Run-length distribution","text":"","category":"section"},{"location":"validation/run_distribution/","page":"Run-length distribution","title":"Run-length distribution","text":"In a random walk where the tumbling events occur as Poissonian events, the resulting distribution of run lengths should be exponentially distributed, with the average run length satisfying tau = 1nu where nu is the average unbiased turn rate of the bacteria.","category":"page"},{"location":"validation/run_distribution/","page":"Run-length distribution","title":"Run-length distribution","text":"Since we don't work with continuous event-based simulations, the integration timestep plays an important role in the resulting distribution. If the timestep is too large compared to the typical run lengths, the resulting distibution will be affected. But if the timestep is too small, the simulations will be too expensive. In most scenarios, a timestep Delta t sim tau10 is typically the largest value with which the correct run length distribution can be properly sampled.","category":"page"},{"location":"validation/run_distribution/","page":"Run-length distribution","title":"Run-length distribution","text":"using MicrobeAgents\n\nL = 1000\nspace = ContinuousSpace((L,L,L))\ndt = 0.1 # s\nmodel = StandardABM(Microbe{3}, space, dt)\n\nruntime_expected = 2.0 # s\nunbiased_turn_rate = 1 / runtime_expected # Hz\nn = 500\nfor i in 1:n\n    add_agent!(model; turn_rate=unbiased_turn_rate)\nend\n\nnsteps = 10000\nadata = [velocity]\nadf, = run!(model, nsteps; adata)","category":"page"},{"location":"validation/run_distribution/","page":"Run-length distribution","title":"Run-length distribution","text":"To verify that we sample the expected distribution, we will first estimate the run lengths in our simulation with Analysis.detect_turns! and Analysis.run_durations, and then we will fit the resulting distribution with an Exponential distribution from Distributions.jl. We expect the fitted distribution to match our histogram and return a timescale tau close to the value of runtime_expected.","category":"page"},{"location":"validation/run_distribution/","page":"Run-length distribution","title":"Run-length distribution","text":"using Distributions\nAnalysis.detect_turns!(adf)\nrun_lengths = vcat(Analysis.run_durations(adf)...) .* dt\nestimated_pdf = fit(Exponential, run_lengths)\nτ = scale(estimated_pdf)\n\nusing Plots\nhistogram(run_lengths; bins=dt/2:2dt:5τ, normalize=:pdf,\n    lab=\"Simulation; τ = $(runtime_expected) s\", lw=0)\nplot!(dt:dt:5τ, t -> pdf(estimated_pdf, t-dt); lw=2,\n    lab=\"exp(-t/τ)/τ; τ = $(round(τ;digits=3)) s\")\nplot!(xlab=\"Δt (s)\", ylab=\"P(Δt)\")","category":"page"},{"location":"validation/velocity_autocorrelations/","page":"Velocity autocorrelation functions","title":"Velocity autocorrelation functions","text":"EditURL = \"../../../examples/Validation/velocity_autocorrelations.jl\"","category":"page"},{"location":"validation/velocity_autocorrelations/#Velocity-autocorrelation-functions","page":"Velocity autocorrelation functions","title":"Velocity autocorrelation functions","text":"","category":"section"},{"location":"validation/velocity_autocorrelations/","page":"Velocity autocorrelation functions","title":"Velocity autocorrelation functions","text":"Orientational correlations in the microbe's motion can be probed through velocity autocorrelation functions. Each motility pattern is characterized by a specific form of the velocity autocorrelation function, which have been analytically evaluated by Taktikos et al (PLoS ONE 2012). We will compare the velocity autocorrelation functions of run-tumble, run-reverse and run-reverse-flick motility, in the absence of rotational diffusion, to the analytical calculations:","category":"page"},{"location":"validation/velocity_autocorrelations/","page":"Velocity autocorrelation functions","title":"Velocity autocorrelation functions","text":"phi(t) = begincases\n    exp(-ttau)  textrun-tumble \n    exp(-2ttau)  textrun-reverse \n    (1 - t2tau)exp(-ttau)  textrun-reverse-flick\nendcases","category":"page"},{"location":"validation/velocity_autocorrelations/","page":"Velocity autocorrelation functions","title":"Velocity autocorrelation functions","text":"using MicrobeAgents\nusing Plots\n\nU = 30.0 # μm/s\nτ_run = 1.0 # s\nturn_rate = 1 / τ_run # 1/s\nΔt = 0.01 # s\nL = 1e4 # μm\nspace = ContinuousSpace((L,L,L))\n\nmodel = StandardABM(Microbe{3}, space, Δt; container=Vector)\nn = 200\nfor Motility in (RunTumble, RunReverse, RunReverseFlick), i in 1:n\n    add_agent!(model; turn_rate, motility=Motility(speed=[U]))\nend\n# keep track of ids of each motile strategy\nids_runtumble = 1:n\nids_runreverse = (1:n) .+ n\nids_runrevflick = (1:n) .+ 2n\n\nnsteps = round(Int, 100τ_run / Δt)\nadata = [velocity]\nadf, = run!(model, nsteps; adata)\n\n# separate the dataframes by motile strategy\nadf_runtumble = filter(:id => id -> id in ids_runtumble, adf; view=true)\nadf_runrev = filter(:id => id -> id in ids_runreverse, adf; view=true)\nadf_runrevflick = filter(:id => id -> id in ids_runrevflick, adf; view=true)\nadfs = [adf_runtumble, adf_runrev, adf_runrevflick]\n\n# evaluate the autocorrelation functions\nusing StatsBase: mean\nt = range(0, (nsteps-1)*Δt; step=Δt)\nΦ = hcat([mean(Analysis.acf(a, :velocity; normalize=true)) for a in adfs]...)\n\n# from Taktikos et al.\nΦ_theoretical = hcat([\n    exp.(-t ./ τ_run),\n    exp.(-t ./ (τ_run / 2)),\n    (1 .- t ./ (2τ_run)) .* exp.(-t ./ τ_run),\n]...)\n\nplot(\n    xlims=(0,6τ_run), ylims=(-0.1, 1.05),\n    xlab=\"Δt / τ\",\n    ylab=\"velocity autocorrelation\",\n)\nplot!(t, Φ_theoretical, lw=2, lc=[1 2 3],\n    label=[\"Run-Tumble\" \"Run-Reverse\" \"Run-Reverse-Flick\"]\n)\n# show simulation values only at selected lags for better visualization\nlags = range(0, length(t)-1; step=20)\nscatter!(t[lags.+1], Φ[lags.+1,:], m=:x, mc=[1 2 3], msw=2, label=false)\nhline!([0.0], lw=0.8, ls=:dash, lc=:black, lab=false)","category":"page"},{"location":"examples/RandomWalks/1_randomwalk1D/","page":"1D Random walk","title":"1D Random walk","text":"EditURL = \"../../../../examples/RandomWalks/1_randomwalk1D.jl\"","category":"page"},{"location":"examples/RandomWalks/1_randomwalk1D/#1D-Random-walk","page":"1D Random walk","title":"1D Random walk","text":"","category":"section"},{"location":"examples/RandomWalks/1_randomwalk1D/","page":"1D Random walk","title":"1D Random walk","text":"Here we simulate a population of one-dimensional random walkers.","category":"page"},{"location":"examples/RandomWalks/1_randomwalk1D/","page":"1D Random walk","title":"1D Random walk","text":"First we shall set up the model: we need to define the microbe type, the space and the integration timestep.","category":"page"},{"location":"examples/RandomWalks/1_randomwalk1D/","page":"1D Random walk","title":"1D Random walk","text":"For the microbe type, we will choose the base type Microbe{1}.","category":"page"},{"location":"examples/RandomWalks/1_randomwalk1D/","page":"1D Random walk","title":"1D Random walk","text":"For the space, we need to set the domain size and whether it is periodic or not. We will use a periodic box with an extent of 1000 μm; if unspecified, ContinuousSpace will default to periodic=true.","category":"page"},{"location":"examples/RandomWalks/1_randomwalk1D/","page":"1D Random walk","title":"1D Random walk","text":"For the integration timestep, we choose a value of 0.1 s.","category":"page"},{"location":"examples/RandomWalks/1_randomwalk1D/","page":"1D Random walk","title":"1D Random walk","text":"Remember that lengths are always assumed to be in units of microns, times in seconds.","category":"page"},{"location":"examples/RandomWalks/1_randomwalk1D/","page":"1D Random walk","title":"1D Random walk","text":"using MicrobeAgents\n\nL = 1000 # space size in μm\nspace = ContinuousSpace((L,))\ndt = 0.1 # integration timestep in s\nmodel = StandardABM(Microbe{1}, space, dt)","category":"page"},{"location":"examples/RandomWalks/1_randomwalk1D/","page":"1D Random walk","title":"1D Random walk","text":"Now that the model is initialized, we will add 10 microbes. If we don't provide any argument on creation, default values from the constructor will be used, i.e., an isotropic RunTumble motility, with speed 30 μm/s, an unbiased tumbling rate of 1 Hz...","category":"page"},{"location":"examples/RandomWalks/1_randomwalk1D/","page":"1D Random walk","title":"1D Random walk","text":"With the first (optional) argument to add_agent!, we can define the starting position of the microbe. For convenience, we will initialize all of them from position (0,).","category":"page"},{"location":"examples/RandomWalks/1_randomwalk1D/","page":"1D Random walk","title":"1D Random walk","text":"n = 10 # number of microbes to add\nforeach(_ -> add_agent!((0,), model), 1:n)","category":"page"},{"location":"examples/RandomWalks/1_randomwalk1D/","page":"1D Random walk","title":"1D Random walk","text":"We can now run the simulation. We just need to define how many timesteps we want to simulate and what kind of data we want to store during the simulation. In this simulation, we only want to collect the microbe positions at each timestep; we then set the adata vector (agent data) to collect the position of the microbes.","category":"page"},{"location":"examples/RandomWalks/1_randomwalk1D/","page":"1D Random walk","title":"1D Random walk","text":"The run! function will return a dataframe for the agent data (adf) and one for the model data (mdf) collected during the simulation. Here we are only collecting agent data and no model data.","category":"page"},{"location":"examples/RandomWalks/1_randomwalk1D/","page":"1D Random walk","title":"1D Random walk","text":"nsteps = 600\nadata = [position]\nadf, _ = run!(model, nsteps; adata);\nnothing #hide","category":"page"},{"location":"examples/RandomWalks/1_randomwalk1D/","page":"1D Random walk","title":"1D Random walk","text":"The simulation is done. We now want to visualize our results. One last thing we need to is to \"unfold\" the trajectories of our microbes. In fact, since we used a periodic domain, if we just plotted the trajectories we would see them crossing between the two sides of the box, which is not what we want.","category":"page"},{"location":"examples/RandomWalks/1_randomwalk1D/","page":"1D Random walk","title":"1D Random walk","text":"With the unfolding, the trajectories are expanded as if they were simulated in an infinite system.","category":"page"},{"location":"examples/RandomWalks/1_randomwalk1D/","page":"1D Random walk","title":"1D Random walk","text":"The unfold! function and other useful post-processing functions can be accessed through the Analysis submodule of MicrobeAgents.jl. unfold! operates directly on the agent dataframe adf and generates a new column :position_unfold from the raw :position column. After the unfolding, we extract the individual trajectories in the form of a matrix with adf_to_matrix, where each trajectory will be stored as a column. This will be convenient for plotting.","category":"page"},{"location":"examples/RandomWalks/1_randomwalk1D/","page":"1D Random walk","title":"1D Random walk","text":"Analysis.unfold!(adf, model)\ntraj = Analysis.adf_to_matrix(adf, :position_unfold)\nx = first.(traj)\nt = axes(x,1) .* dt\n\nusing Plots\nplot(t, x, leg=false, xlab=\"time\", ylab=\"displacement\")","category":"page"},{"location":"examples/Chemotaxis/2_celani_gauss2D/","page":"Noisy chemotaxis towards Gaussian source","title":"Noisy chemotaxis towards Gaussian source","text":"EditURL = \"../../../../examples/Chemotaxis/2_celani_gauss2D.jl\"","category":"page"},{"location":"examples/Chemotaxis/2_celani_gauss2D/#Noisy-chemotaxis-towards-Gaussian-source","page":"Noisy chemotaxis towards Gaussian source","title":"Noisy chemotaxis towards Gaussian source","text":"","category":"section"},{"location":"examples/Chemotaxis/2_celani_gauss2D/","page":"Noisy chemotaxis towards Gaussian source","title":"Noisy chemotaxis towards Gaussian source","text":"In this example we set up a static Gaussian source and observe the chemotactic behavior of the Celani model, in the presence of sensing noise (via the chemotactic_precision). Playing with the chemotactic_precision, it can be seen that the clustering of bacteria at the source becomes stronger with decreasing noise (decreasing chemotactic precision).","category":"page"},{"location":"examples/Chemotaxis/2_celani_gauss2D/","page":"Noisy chemotaxis towards Gaussian source","title":"Noisy chemotaxis towards Gaussian source","text":"using MicrobeAgents\nusing Plots\n\nfunction concentration_field(pos, model)\n    C = model.C\n    σ = model.σ\n    p₀ = model.p₀\n    concentration_field(pos, p₀, C, σ)\nend\nconcentration_field(pos, p₀, C, σ) = C * exp(-sum(abs2.(pos.-p₀))/(2*σ^2))\n\ntimestep = 0.1 # s\nextent = ntuple(_ -> 1000.0, 2) # μm\nspace = ContinuousSpace(extent; periodic=false)\np₀ = extent./2 # μm\nC = 1.0 # μM\nσ = 100.0 # μm\nproperties = Dict(\n    :chemoattractant => GenericChemoattractant{2,Float64}(; concentration_field),\n    :C => C,\n    :σ => σ,\n    :p₀ => p₀,\n)\n\nmodel = StandardABM(Celani{2}, space, timestep; properties)\nforeach(_ -> add_agent!(model; chemotactic_precision=6.0), 1:300)\n\nnsteps = 5000\nadata = [position]\nadf, = run!(model, nsteps; adata)\n\ntraj = Analysis.adf_to_matrix(adf, :position)\nxmesh = range(0, first(spacesize(model)); length=100)\nymesh = range(0, last(spacesize(model)); length=100)\nc = [concentration_field(p, p₀, C, σ) for p in Iterators.product(xmesh, ymesh)]\nheatmap(xmesh, ymesh, c', cbar=false, ratio=1, c=:bone, axis=false)\nx = getindex.(traj,1)[end-100:4:end, :]\ny = getindex.(traj,2)[end-100:4:end, :]\na = axes(x,1) ./ size(x,1)\nplot!(x, y,\n    lab=false, lims=(0,1000), lw=1, alpha=a\n)","category":"page"},{"location":"randomwalks/#Random-walks","page":"Random walks","title":"Random walks","text":"","category":"section"},{"location":"randomwalks/","page":"Random walks","title":"Random walks","text":"Generating random walks with MicrobeAgents.jl is super-easy, and the walk properties can be fine-tuned to match all sorts of needs.","category":"page"},{"location":"randomwalks/","page":"Random walks","title":"Random walks","text":"By default, MicrobeAgents.jl produces random walks composed of runs at constant speed and arbitrary reorientations where the waiting times between such reorientations are i.i.d. random variables. In the absence of chemotaxis (or other behavioral responses that affect microbe motility), the generated random walks will display an exponential distribution of waiting times.","category":"page"},{"location":"randomwalks/#Random-Walk-in-D1","page":"Random walks","title":"Random Walk in D=1","text":"","category":"section"},{"location":"randomwalks/","page":"Random walks","title":"Random walks","text":"using MicrobeAgents\n\nL = 1000\nspace = ContinuousSpace((L,))\ndt = 0.1\nn = 10\nnsteps = 600\n\nmodel = StandardABM(Microbe{1}, space, dt; container=Vector)\nforeach(_ -> add_agent!((0,), model), 1:n)","category":"page"},{"location":"randomwalks/","page":"Random walks","title":"Random walks","text":"By default, ContinuousSpace will create a periodic domain; this will allow us to mimic an \"infinite\" system. All the microbes have been initialized from position 0, without specifying any further property, so they will be initialized with a random velocity (either (+1,) or (-1,) in this 1D scenario), speed=30.0, and turn_rate=1.0. The motility is set by default to RunTumble(speed=[30.0]) but any other motile pattern in 1D would produce the same result; only speed is relevant here.","category":"page"},{"location":"randomwalks/","page":"Random walks","title":"Random walks","text":"To run the simulation while collecting the bacterial positions at each step we will then run","category":"page"},{"location":"randomwalks/","page":"Random walks","title":"Random walks","text":"adata = [position]\nadf, _ = run!(model, nsteps; adata)","category":"page"},{"location":"randomwalks/","page":"Random walks","title":"Random walks","text":"Since the simulation box is periodic, the trajectories we collected in adf fold around at the box edges. We can unfold them with the unfold! function available through the Analysis submodule. The unfolded coordinates will be stored in a new column :position_unfold. For convenient plotting we can turn this new dataframe column into a matrix with one trajectory per column with adf_to_matrix.","category":"page"},{"location":"randomwalks/","page":"Random walks","title":"Random walks","text":"Analysis.unfold!(adf, model)\ntrajectories = Analysis.adf_to_matrix(adf, :position_unfold)","category":"page"},{"location":"randomwalks/","page":"Random walks","title":"Random walks","text":"trajectories is now a Matrix{SVector{1,Float64}}. To obtain the x positions for plotting we can call","category":"page"},{"location":"randomwalks/","page":"Random walks","title":"Random walks","text":"x = first.(trajectories)\nt = axes(x,1) .* dt\nplot(t,x,lab=false,xlab=\"time\",ylab=\"displacement\")","category":"page"},{"location":"randomwalks/#Random-walks-with-different-motile-patterns-in-D2","page":"Random walks","title":"Random walks with different motile patterns in D=2","text":"","category":"section"},{"location":"randomwalks/","page":"Random walks","title":"Random walks","text":"The procedure to generate a random walk in higher dimensions is exactly the same","category":"page"},{"location":"randomwalks/","page":"Random walks","title":"Random walks","text":"L = 500\nspace = ContinuousSpace((L,L))\ndt = 0.1\nnsteps = 600\n\nmodel = StandardABM(Microbe{2}, space, dt; container=Vector)","category":"page"},{"location":"randomwalks/","page":"Random walks","title":"Random walks","text":"But we can now add bacteria with different motility patterns (we import Distributions.jl to use a Normal distribution for the speed of one of our microbes)","category":"page"},{"location":"randomwalks/","page":"Random walks","title":"Random walks","text":"using Distributions\nadd_agent!(model; motility=RunReverse(speed_forward=[55]), rotational_diffusivity=0.2)\nadd_agent!(model; motility=RunTumble(speed=Normal(30,6)), turn_rate=0.5)\nadd_agent!(model; motility=RunReverseFlick(speed_backward=[6]), rotational_diffusivity=0.1)","category":"page"},{"location":"randomwalks/","page":"Random walks","title":"Random walks","text":"and then we run and visualize as before","category":"page"},{"location":"randomwalks/","page":"Random walks","title":"Random walks","text":"adata = [:pos]\nadf, _ = run!(model, nsteps; adata)\n\n# postprocessing\ntraj = MicrobeAgents.unfold(vectorize_adf_measurement(adf,:pos), L)\nx = first.(traj)\ny = last.(traj)\nt = axes(x,1) .* dt\nplot(x, y, xlab=\"x\", ylab=\"y\", ratio=1,\n    lab=[\"RunReverse\" \"RunTumble\" \"RunReverseFlick\"]\n)","category":"page"},{"location":"randomwalks/","page":"Random walks","title":"Random walks","text":"(Image: Two-dimensional random walks with different motility patterns)","category":"page"},{"location":"examples/Chemotaxis/5_drift_exponential/","page":"Chemotactic drift in exponential ramp with noisy sensing","title":"Chemotactic drift in exponential ramp with noisy sensing","text":"EditURL = \"../../../../examples/Chemotaxis/5_drift_exponential.jl\"","category":"page"},{"location":"examples/Chemotaxis/5_drift_exponential/#Chemotactic-drift-in-exponential-ramp-with-noisy-sensing","page":"Chemotactic drift in exponential ramp with noisy sensing","title":"Chemotactic drift in exponential ramp with noisy sensing","text":"","category":"section"},{"location":"examples/Chemotaxis/5_drift_exponential/","page":"Chemotactic drift in exponential ramp with noisy sensing","title":"Chemotactic drift in exponential ramp with noisy sensing","text":"We will peform simulations of chemotaxis in an exponential concentration ramp using the Brumley model of chemotaxis and measure their drift velocity along the gradient. The concentration field has the form","category":"page"},{"location":"examples/Chemotaxis/5_drift_exponential/","page":"Chemotactic drift in exponential ramp with noisy sensing","title":"Chemotactic drift in exponential ramp with noisy sensing","text":"C(x) = C_0exp(xλ)","category":"page"},{"location":"examples/Chemotaxis/5_drift_exponential/","page":"Chemotactic drift in exponential ramp with noisy sensing","title":"Chemotactic drift in exponential ramp with noisy sensing","text":"and its gradient is","category":"page"},{"location":"examples/Chemotaxis/5_drift_exponential/","page":"Chemotactic drift in exponential ramp with noisy sensing","title":"Chemotactic drift in exponential ramp with noisy sensing","text":"nabla C(x) = dfracC_0lambdaexp(xlambda)hatmathbfx","category":"page"},{"location":"examples/Chemotaxis/5_drift_exponential/","page":"Chemotactic drift in exponential ramp with noisy sensing","title":"Chemotactic drift in exponential ramp with noisy sensing","text":"In the Brumley model, the microbe estimates the local gradient in the form of the convective derivative of the concentration field (Unabla C). The measurement is affected by noise, represented by an intrinsic noise term sigma = sqrt3C(pi a D_c T^3) (Mora & Wingreen (Phys Rev Lett 2010), where a is the microbe radius, T the chemotactic sensory timescale and D_c the thermal diffusivity of the chemoattractant compound) and a pre-factor Pi which represents the \"chemotactic precision\". Higher values of Pi imply higher levels of noise in chemotaxis pathway.","category":"page"},{"location":"examples/Chemotaxis/5_drift_exponential/","page":"Chemotactic drift in exponential ramp with noisy sensing","title":"Chemotactic drift in exponential ramp with noisy sensing","text":"Therefore, with each measurement the bacterium samples from a Normal distribution with mean Unabla C and standard deviation Pisigma. The measurement, mathcalM, determines the evolution of an internal state S which obeys an excitation-relaxation dynamics:","category":"page"},{"location":"examples/Chemotaxis/5_drift_exponential/","page":"Chemotactic drift in exponential ramp with noisy sensing","title":"Chemotactic drift in exponential ramp with noisy sensing","text":"dotS = kappa M -dfracStau_M","category":"page"},{"location":"examples/Chemotaxis/5_drift_exponential/","page":"Chemotactic drift in exponential ramp with noisy sensing","title":"Chemotactic drift in exponential ramp with noisy sensing","text":"This internal state, in turn, determines the tumbling rate.","category":"page"},{"location":"examples/Chemotaxis/5_drift_exponential/","page":"Chemotactic drift in exponential ramp with noisy sensing","title":"Chemotactic drift in exponential ramp with noisy sensing","text":"We will study how Pi affects the drift velocity of bacteria.","category":"page"},{"location":"examples/Chemotaxis/5_drift_exponential/","page":"Chemotactic drift in exponential ramp with noisy sensing","title":"Chemotactic drift in exponential ramp with noisy sensing","text":"using MicrobeAgents\n\nfunction concentration_field(pos, model)\n    x = first(pos)\n    C0 = model.C0\n    λ = model.λ\n    concentration_field(x, C0, λ)\nend\nconcentration_field(x, C0, λ) = C0*exp(x/λ)\n\nfunction concentration_gradient(pos, model)\n    x = first(pos)\n    C0 = model.C0\n    λ = model.λ\n    concentration_gradient(x, C0, λ)\nend\nconcentration_gradient(x, C0, λ) = SVector{3}(i==1 ? C0/λ*exp(x/λ) : 0.0 for i in 1:3)\n\n# wide rectangular channel confined in the z direction\nLx, Ly, Lz = 6000, 3000, 100\nspace = ContinuousSpace((Lx,Ly,Lz); periodic=false)\ndt = 0.1\n\nC0 = 10.0\nλ = Lx/2\nproperties = Dict(\n    :chemoattractant => GenericChemoattractant{3,Float64}(;\n        concentration_field,\n        concentration_gradient\n    ),\n    :C0 => C0,\n    :λ => λ,\n)\nmodel = StandardABM(Brumley{3}, space, dt; properties, container=Vector)\n\n# add n bacteria for each value of Π\n# all of them initialized at x = 0\nΠs = [1.0, 2.0, 5.0, 10.0, 25.0]\nn = 200\nfor Π in Πs\n    for i in 1:n\n        pos = SVector{3}(0.0, rand()*Ly, rand()*Lz)\n        add_agent!(pos, model; chemotactic_precision=Π)\n    end\nend\n\n# also store Π for grouping later\nadata = [position, velocity, :chemotactic_precision]\nnsteps = 2000\nadf, = run!(model, nsteps; adata)\n\n# evaluate drift velocity along x direction\ntarget_direction = SVector(1.0, 0.0, 0.0)\nAnalysis.driftvelocity_direction!(adf, target_direction)\n\n# we now want to first average the drift velocities in each group of Π values\n# and then average each group over time to obtain a mean drift\n# the calculation is much easier to perform with the DataFrames package\nusing DataFrames, StatsBase\ngdf = groupby(adf, :chemotactic_precision)\ndrift_velocities = zeros(1+nsteps, length(Πs))\nfor (i,g) in enumerate(gdf)\n    for h in groupby(g, :id)\n        drift_velocities[:,i] .+= h.drift_direction\n    end\n    drift_velocities[:,i] ./= n\nend\navg_drift = vec(mean(drift_velocities; dims=1))\n\n# we apply a smoothing function to remove some noise for better visualization\nfunction moving_average(y::AbstractVector, m::Integer)\n    @assert isodd(m)\n    out = similar(y)\n    R = CartesianIndices(y)\n    Ifirst, Ilast = first(R), last(R)\n    I1 = m÷2 * oneunit(Ifirst)\n    for I in R\n        n, s = 0, zero(eltype(out))\n        for J in max(Ifirst, I-I1):min(Ilast, I+I1)\n            s += y[J]\n            n += 1\n        end\n        out[I] = s/n\n    end\n    return out\nend\nsmoothing_window = 51\nsmooth_drift_velocities = mapslices(\n    y -> moving_average(y, smoothing_window), drift_velocities;\n    dims = 1\n)\n\nusing Plots\nt = axes(smooth_drift_velocities, 1) .* dt\nplot(layout=(1,2), size=(760,440),\n    plot(t, smooth_drift_velocities, lab=Πs',\n        xlab=\"t (s)\", ylab=\"drift (μm/s)\"\n    ),\n    plot(Πs, avg_drift, lw=4, m=:c, ms=8, lab=false,\n        xlab=\"Π\", ylab=\"avg drift (μm/s)\"\n    )\n)","category":"page"},{"location":"examples/Chemotaxis/5_drift_exponential/","page":"Chemotactic drift in exponential ramp with noisy sensing","title":"Chemotactic drift in exponential ramp with noisy sensing","text":"Increasing Π significantly reduces the ability of bacteria to drift along the gradient.","category":"page"},{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#Microbes","page":"API","title":"Microbes","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"AbstractMicrobe\nMicrobe\nBrownBerg\nBrumley\nCelani\nXie","category":"page"},{"location":"api/#MicrobeAgents.AbstractMicrobe","page":"API","title":"MicrobeAgents.AbstractMicrobe","text":"AbstractMicrobe{D} <: AbstractAgent where {D<:Integer}\n\nAll microbe types in MicrobeAgents.jl simulations must be instances of user-defined types that are subtypes of AbstractMicrobe.     YourMicrobeType{D} <: AbstractMicrobe{D} The parameter D defines the dimensionality of the space in which the microbe type lives (1, 2 and 3 are supported).\n\nAll microbe types must have at least the following fields:\n\nid::Int id of the microbe (used internally by Agents.jl)\npos::SVectpr{D,Float64} position of the microbe\nvel::SVector{D,Float64} velocity of the microbe\nmotility::AbstractMotility motile pattern of the microbe\nturn_rate::Real average reorientation rate of the microbe\nrotational_diffusivity::Real coefficient of brownian rotational diffusion\nradius::Real equivalent spherical radius of the microbe\nstate::Real generic variable for a scalar internal state\n\n\n\n\n\n","category":"type"},{"location":"api/#MicrobeAgents.Microbe","page":"API","title":"MicrobeAgents.Microbe","text":"Microbe{D} <: AbstractMicrobe{D}\n\nBase microbe type for simple simulations.\n\nMicrobe has the required fields\n\nid::Int an identifier used internally\npos::SVector{D,Float64} spatial position\nvel::SVector{D,Float64} unit velocity vector\nspeed::Float64 magnitude of the velocity vector\n\nand the default parameters\n\nmotility::AbstractMotility = RunTumble() motile pattern of the microbe\nturn_rate::Float64 = 1.0 frequency of reorientations\nrotational_diffusivity::Float64 = 0.0 coefficient of brownian rotational diffusion\nradius::Float64 = 0.0 equivalent spherical radius of the microbe\nstate::Float64 = 0.0 generic variable for a scalar internal state\n\n\n\n\n\n","category":"type"},{"location":"api/#MicrobeAgents.BrownBerg","page":"API","title":"MicrobeAgents.BrownBerg","text":"BrownBerg{D} <: AbstractMicrobe{D}\n\nModel of chemotactic E.coli from 'Brown and Berg (1974) PNAS'\n\nDefault parameters:\n\nmotility = RunTumble()\nturn_rate = 1.49 Hz frequency of reorientations\nrotational_diffusivity = 0.035 rad²/s coefficient of brownian rotational diffusion\nradius = 0.5 μm equivalent spherical radius of the microbe\nstate = 0.0 corresponds to 'weighted dPb/dt' in the paper\ngain = 660 s\nreceptor_binding_constant = 100 μM\nmemory = 1 s\n\n\n\n\n\n","category":"type"},{"location":"api/#MicrobeAgents.Brumley","page":"API","title":"MicrobeAgents.Brumley","text":"Brumley{D} <: AbstractMicrobe{D}\n\nModel of chemotactic bacterium from 'Brumley et al. (2019) PNAS'. The model is optimized for simulation of marine bacteria and accounts for the presence of (gaussian) sensing noise in the chemotactic pathway.\n\nDefault parameters:\n\nmotility = RunReverseFlick(speed = [46.5])\nturn_rate = 2.22 Hz → '1/τ₀'\nstate = 0.0 → 'S'\nrotational_diffusivity = 0.035 rad²/s\nmemory = 1.3 s → 'τₘ'\ngain_receptor = 50.0 μM⁻¹ → 'κ'\ngain = 50.0 → 'Γ'\nchemotactic_precision = 6.0 → 'Π'\nradius = 0.5 μm → 'a'\n\n\n\n\n\n","category":"type"},{"location":"api/#MicrobeAgents.Celani","page":"API","title":"MicrobeAgents.Celani","text":"Celani{D} <: AbstractMicrobe{D}\n\nModel of chemotactic bacterium using the response kernel from 'Celani and Vergassola (2010) PNAS', extracted from experiments on E. coli.\n\nSensing noise (not present in the original model) is customarily introduced through the molecular counting noise formula by Berg and Purcell, and can be tuned through a chemotactic_precision factor inspired by 'Brumley et al. (2019) PNAS' (defaults to 0, i.e. no noise).\n\nDefault parameters:\n\nmotility = RunTumble(speed = [30.0])\nturn_rate = 1.49 Hz\nstate = 0\nrotational_diffusivity = 0.26 rad²/s\ngain = 50.0\nmemory = 1 s\nradius = 0.5 μm\n\n\n\n\n\n","category":"type"},{"location":"api/#MicrobeAgents.Xie","page":"API","title":"MicrobeAgents.Xie","text":"Xie{D} <: AbstractMicrobe{D}\n\nModel of chemotactic bacterium adapted from 'Xie et al. (2019) Biophys J'. The model is developed based on experimental measurements of the chemotactic response function in the marine bacterium V. alginolyticus. The peculiarity of the model is the presence of distinct parameters for the forward and backward swimming states.\n\nSensing noise (not present in the original model) is customarily introduced through the molecular counting noise formula by Berg and Purcell, and can be tuned through a chemotactic_precision factor inspired by 'Brumley et al. (2019) PNAS' (defaults to 0, i.e. no noise).\n\nDefault parameters:\n\nmotility = RunReverseFlick(speed = [46.5])\nturn_rate_forward = 2.3 Hz\nturn_rate_backward = 1.9 Hz\nstate = 0.0 s\nstate_m = 0.0 s\nstate_z = 0.0 s\nrotational_diffusivity = 0.26 rad²/s\nadaptation_time_m = 1.29 s\nadaptation_time_z = 0.28 s\ngain_forward = 2.7 1/s\ngain_backward = 1.6 1/s\nbinding_affinity = 0.39 μM\nchemotactic_precision = 0.0\nradius = 0.5 μm\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"position\ndirection\nspeed\nvelocity\nmotilepattern\nturnrate\nrotational_diffusivity\nradius\nstate","category":"page"},{"location":"api/#Base.position","page":"API","title":"Base.position","text":"position(m::AbstractMicrobe)\n\nReturn the position of the microbe.\n\n\n\n\n\n","category":"function"},{"location":"api/#MicrobeAgents.direction","page":"API","title":"MicrobeAgents.direction","text":"direction(m::AbstractMicrobe)\n\nReturn the direction versor of the microbe.\n\n\n\n\n\n","category":"function"},{"location":"api/#MicrobeAgents.speed","page":"API","title":"MicrobeAgents.speed","text":"speed(m::AbstractMicrobe)\n\nReturn the speed of the microbe.\n\n\n\n\n\n","category":"function"},{"location":"api/#MicrobeAgents.velocity","page":"API","title":"MicrobeAgents.velocity","text":"velocity(m::AbstractMicrobe)\n\nReturn the velocity vector of the microbe (direction times speed).\n\n\n\n\n\n","category":"function"},{"location":"api/#MicrobeAgents.motilepattern","page":"API","title":"MicrobeAgents.motilepattern","text":"motilepattern(m::AbstractMicrobe)\n\nReturn the motile pattern of the microbe.\n\n\n\n\n\n","category":"function"},{"location":"api/#MicrobeAgents.turnrate","page":"API","title":"MicrobeAgents.turnrate","text":"turnrate(m::AbstractMicrobe)\n\nReturn the unbiased turn rate of the microbe.\n\n\n\n\n\n","category":"function"},{"location":"api/#MicrobeAgents.rotational_diffusivity","page":"API","title":"MicrobeAgents.rotational_diffusivity","text":"rotational_diffusivity(m::AbstractMicrobe)\n\nReturn the rotational diffusivity of the microbe.\n\n\n\n\n\n","category":"function"},{"location":"api/#MicrobeAgents.radius","page":"API","title":"MicrobeAgents.radius","text":"radius(m::AbstractMicrobe)\n\nReturn the radius of the microbe.\n\n\n\n\n\n","category":"function"},{"location":"api/#MicrobeAgents.state","page":"API","title":"MicrobeAgents.state","text":"state(m::AbstractMicrobe)\n\nReturn the internal state of the microbe.\n\n\n\n\n\n","category":"function"},{"location":"api/#Motility","page":"API","title":"Motility","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"AbstractMotility\nMotilityOneStep\nMotilityTwoStep\nRunTumble\nRunReverse\nRunReverseFlick","category":"page"},{"location":"api/#MicrobeAgents.AbstractMotility","page":"API","title":"MicrobeAgents.AbstractMotility","text":"AbstractMotility\n\nGeneral abstract interface for motility patterns.\n\n\n\n\n\n","category":"type"},{"location":"api/#MicrobeAgents.MotilityOneStep","page":"API","title":"MicrobeAgents.MotilityOneStep","text":"MotilityOneStep\n\nType for one-step motility patterns (e.g. RunTumble).\n\nA MotilityOneStep has the fields\n\nspeed: distribution of microbe speed, new values extracted after each turn\npolar: distribution of polar angles\nazimuthal: distribution azimuthal angles\n\nFor 2-dimensional microbe types, only polar defines reorientations and azimuthal is ignored.\n\n\n\n\n\n","category":"type"},{"location":"api/#MicrobeAgents.MotilityTwoStep","page":"API","title":"MicrobeAgents.MotilityTwoStep","text":"MotilityTwoStep\n\nType for two-step motility patterns (e.g. RunReverse, RunReverseFlick) In two-step motility patterns, the two \"steps\" can have different properties.\n\nA MotilityTwoStep has the fields\n\nspeed: distribution of microbe speed, new values extracted after each turn\npolar: distribution of in-plane reorientations for motile state fw\nazimuthal: distribution of out-of-plane reorientations for motile state fw\nspeed_backward: distribution of microbe speed, new values extracted after each turn\npolar_backward: distribution of in-plane reorientations for motile state bw\nazimuthal_backward: distribution of out-of-plane reorientations for motile state bw\nmotile_state: defines current motile state (e.g. Forward or Backward for a TwoState)\n\nFor 2-dimensional microbe types, only polar distributions define reorientations while azimuthal ones are ignored.\n\n\n\n\n\n","category":"type"},{"location":"api/#MicrobeAgents.RunTumble","page":"API","title":"MicrobeAgents.RunTumble","text":"RunTumble(; speed=(30.0,), polar=Uniform(-π,π), azimuthal=Arccos())\n\nConstructor for a MotilityOneStep with default values associated to run-and-tumble motion.\n\n\n\n\n\n","category":"function"},{"location":"api/#MicrobeAgents.RunReverse","page":"API","title":"MicrobeAgents.RunReverse","text":"RunReverse(; speed=(30.0,), polar=(π,), azimuthal=Arccos(), speed_backward=speed, polar_backward=polar, azimuthal_backward=azimuthal)\n\nConstructor for a MotilityTwoStep with default values associated to run-reverse motion.\n\n\n\n\n\n","category":"function"},{"location":"api/#MicrobeAgents.RunReverseFlick","page":"API","title":"MicrobeAgents.RunReverseFlick","text":"RunReverseFlick(; speed=(30.0,), polar=(π,), azimuthal=Arccos(), speed_backward=speed, polar_backward=(-π/2,π/2), azimuthal_backward=azimuthal)\n\nConstructor for a MotilityTwoStep with default values associated to run-reverse-flick motion.\n\n\n\n\n\n","category":"function"},{"location":"api/#Utils","page":"API","title":"Utils","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"distance\ndistancevector\nrandom_speed\nrandom_velocity\nAnalysis.adf_to_matrix\nAnalysis.adf_to_vectors\nAnalysis.unfold\nAnalysis.unfold!","category":"page"},{"location":"api/#MicrobeAgents.distance","page":"API","title":"MicrobeAgents.distance","text":"distance(a, b, model)\n\nEvaluate the euclidean distance between a and b respecting the boundary conditions of the model\n\n\n\n\n\n","category":"function"},{"location":"api/#MicrobeAgents.distancevector","page":"API","title":"MicrobeAgents.distancevector","text":"distancevector(a, b, model)\n\nEvaluate the distance vector from a to b respecting the boundary conditions of the model.\n\n\n\n\n\n","category":"function"},{"location":"api/#MicrobeAgents.random_speed","page":"API","title":"MicrobeAgents.random_speed","text":"random_speed(microbe, model)\n\nGenerate a random speed from the motile pattern of microbe.\n\n\n\n\n\n","category":"function"},{"location":"api/#MicrobeAgents.random_velocity","page":"API","title":"MicrobeAgents.random_velocity","text":"random_velocity(model)\n\nGenerate a random velocity vector with unit norm respecting the dimensionality of model.\n\n\n\n\n\n","category":"function"},{"location":"api/#MicrobeAgents.Analysis.adf_to_matrix","page":"API","title":"MicrobeAgents.Analysis.adf_to_matrix","text":"adf_to_matrix(adf, sym)\n\nCollect quantity sym from the agent dataframe adf and return it in matrix form with dimensions (times, microbes). Requires all microbes to exist from start to end of the simulations  (no removals or insertions).\n\n\n\n\n\n","category":"function"},{"location":"api/#MicrobeAgents.Analysis.adf_to_vectors","page":"API","title":"MicrobeAgents.Analysis.adf_to_vectors","text":"adf_to_vectors(adf, sym)\n\nCollect quantity sym from the agent dataframe adf and return a vector of such quantity for each microbe id.\n\n\n\n\n\n","category":"function"},{"location":"api/#MeanSquaredDisplacement.unfold!","page":"API","title":"MeanSquaredDisplacement.unfold!","text":"unfold!(adf, model; key=:position)\nunfold!(adf, extent; key=:position)\nunfold!(gdf, model; key=:position)\nunfold!(gdf, extent; key=:position)\n\nUnfold the periodic trajectories contained in the agent dataframe adf or in the grouped dataframe gdf where each microbe trajectory was grouped by :id. The second argument can be either the spatial extent of the model, or the model itself from which the extent is automatically extracted.\n\nThe keyword argument key=:position determines what column of the dataframe has to be unfolded.\n\n\n\n\n\n","category":"function"},{"location":"api/#Analysis","page":"API","title":"Data analysis","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Analysis.detect_turns!\nAnalysis.run_durations\nAnalysis.driftvelocity_point!\nAnalysis.driftvelocity_direction!\nmsd\nacf","category":"page"},{"location":"api/#MicrobeAgents.Analysis.detect_turns!","page":"API","title":"MicrobeAgents.Analysis.detect_turns!","text":"detect_turns!(adf; threshold_angle=0.0, kwargs...)\n\nDetect reorientations in the microbe trajectories in adf. Requires adf to have a velocity column. In order to be detected, a reorientation must be larger than the threshold_angle (in radians); the threshold defaults to 0.\n\nA new column is added to the dataframe, with values true when the microbe has turned with respect to the previous frame, or false otherwise.\n\nKeywords\n\nvel_key::Symbol = :velocity: name of the column containing microbe velocities\nnew_key::Symbol = :has_turned: name of the new column storing turn statistics\n\n\n\n\n\n","category":"function"},{"location":"api/#MicrobeAgents.Analysis.run_durations","page":"API","title":"MicrobeAgents.Analysis.run_durations","text":"run_durations(adf; turns_key=:has_turned)\n\nEvaluate the duration (in frames) of all runs detected during a simulation. The dataframe should already contain a column of Bools with values true for frames when a turn has occurred and false otherwise (see detect_turns!). The function returns a vector of run durations for each microbe.\n\nturns_key defines the name of the column where the turn statistics is stored (defaults to :has_turned).\n\n\n\n\n\n","category":"function"},{"location":"api/#MicrobeAgents.Analysis.driftvelocity_point!","page":"API","title":"MicrobeAgents.Analysis.driftvelocity_point!","text":"driftvelocity_point!(adf, target; normalize=false, kwargs...)\ndriftvelocity_point!(gdf, target; normalize=false, kwargs...)\n\nEvaluate the drift velocity of microbes towards a target point, extracting their positions and velocities from the agent dataframe adf or from the grouped dataframe gdf (grouped by :id). Requires the existence of columns containing the position and velocity of microbes. By convention the drift velocity will be positive for motion towards the target point.\n\nKeywords\n\nnormalize = false: whether drift velocities should be normalized by the instantaneous speed of the microbes\npos_key::Symbol = :position: name of the column containing microbe positions\nvel_key::Symbol = :velocity: name of the column containing microbe velocities\n\n\n\n\n\n","category":"function"},{"location":"api/#MicrobeAgents.Analysis.driftvelocity_direction!","page":"API","title":"MicrobeAgents.Analysis.driftvelocity_direction!","text":"driftvelocity_direction!(adf, target; normalize=false, kwargs...)\ndriftvelocity_direction!(gdf, target; normalize=false, kwargs...)\n\nEvaluate the drift velocity of microbes along a target direction, extracting their positions and velocities from the agent dataframe adf or from the grouped dataframe gdf (grouped by :id). Requires the existence of a column containing the velocity of microbes. By convention the drift velocity will be positive for motion along the target directoin.\n\nKeywords\n\nnormalize = false: whether drift velocities should be normalized by the instantaneous speed of the microbes\nvel_key::Symbol = :velocity: name of the column containing microbe velocities\n\n\n\n\n\n","category":"function"},{"location":"examples/Chemotaxis/4_response_functions/","page":"Comparison of chemotactic response functions","title":"Comparison of chemotactic response functions","text":"EditURL = \"../../../../examples/Chemotaxis/4_response_functions.jl\"","category":"page"},{"location":"examples/Chemotaxis/4_response_functions/#Comparison-of-chemotactic-response-functions","page":"Comparison of chemotactic response functions","title":"Comparison of chemotactic response functions","text":"","category":"section"},{"location":"examples/Chemotaxis/4_response_functions/","page":"Comparison of chemotactic response functions","title":"Comparison of chemotactic response functions","text":"Here we will compare the chemotactic response function of the Celani and BrownBerg model to an impulse stimulus of chemoattractant.","category":"page"},{"location":"examples/Chemotaxis/4_response_functions/","page":"Comparison of chemotactic response functions","title":"Comparison of chemotactic response functions","text":"While Celani only needs the concentration_field to determine the chemotactic response, BrownBerg also needs the the time derivative (concentration_ramp) to be defined explicitly (also the concentration_gradient but it's not relevant in this specific study).","category":"page"},{"location":"examples/Chemotaxis/4_response_functions/","page":"Comparison of chemotactic response functions","title":"Comparison of chemotactic response functions","text":"using MicrobeAgents\nusing Plots\n\nθ(a,b) = a>b ? 1.0 : 0.0 # Heaviside theta function\nfunction concentration_field(pos, model)\n    C₀ = model.C₀\n    C₁ = model.C₁\n    t₁ = model.t₁\n    t₂ = model.t₂\n    dt = model.timestep\n    t = abmtime(model) * dt\n    concentration_field(t, C₀, C₁, t₁, t₂)\nend\nconcentration_field(t,C₀,C₁,t₁,t₂) = C₀+C₁*θ(t,t₁)*(1-θ(t,t₂))\n\nδ(t,dt) = 0 <= t <= dt ? 1.0/dt : 0.0 # discrete approximation to Dirac delta\nfunction concentration_ramp(pos, model)\n    C₀ = model.C₀\n    C₁ = model.C₁\n    t₁ = model.t₁\n    t₂ = model.t₂\n    dt = model.timestep\n    t = abmtime(model) * dt\n    concentration_ramp(t, C₀, C₁, t₁, t₂, dt)\nend\nfunction concentration_ramp(t, C₀, C₁, t₁, t₂, dt)\n    C₁*(δ(t-t₁, dt) - δ(t-t₂, dt))\nend\n\nspace = ContinuousSpace(ntuple(_ -> 500.0, 3)) # μm\nC₀ = 1.0 # μM\nC₁ = 2.0-C₀ # μM\nT = 50.0 # s\ndt = 0.1 # s\nt₁ = 10.0 # s\nt₂ = 30.0 # s\nproperties = Dict(\n    :chemoattractant => GenericChemoattractant{3,Float64}(;\n        concentration_field,\n        concentration_ramp\n    ),\n    :C₀ => C₀,\n    :C₁ => C₁,\n    :t₁ => t₁,\n    :t₂ => t₂,\n)\n\nmodel = StandardABM(Union{BrownBerg{3},Celani{3}}, space, dt; properties)\n\nadd_agent!(BrownBerg{3}, model; turn_rate=0, motility=RunTumble(speed=[0]),\n    memory=1,\n)\nadd_agent!(Celani{3}, model; turn_rate=0, motility=RunTumble(speed=[0]), gain=4)\nadd_agent!(Celani{3}, model; turn_rate=0, motility=RunTumble(speed=[0]), gain=4,\n    chemotactic_precision=50.0\n)\n\nnsteps = round(Int, T/dt)\nadata = [tumblebias]\nadf, = run!(model, nsteps; adata)\n\nS = Analysis.adf_to_matrix(adf, :tumblebias)\n\n_pink = palette(:default)[4]\nplot()\nx = (0:dt:T) .- t₁\nplot!(\n    x, S,\n    lw=1.5, lab=[\"BrownBerg\" \"Celani\" \"Celani + Noise\"]\n)\nplot!(ylims=(-0.1,2.1), ylab=\"Response\", xlab=\"time (s)\")\nplot!(twinx(),\n    x, t -> concentration_field(t.+t₁,C₀,C₁,t₁,t₂),\n    ls=:dash, lw=1.5, lc=_pink, lab=false,\n    tickfontcolor=_pink,\n    ylab=\"C (μM)\", guidefontcolor=_pink\n)","category":"page"},{"location":"examples/RandomWalks/3_randomwalk3D/","page":"3D Random walk","title":"3D Random walk","text":"EditURL = \"../../../../examples/RandomWalks/3_randomwalk3D.jl\"","category":"page"},{"location":"examples/RandomWalks/3_randomwalk3D/#3D-Random-walk","page":"3D Random walk","title":"3D Random walk","text":"","category":"section"},{"location":"examples/RandomWalks/3_randomwalk3D/","page":"3D Random walk","title":"3D Random walk","text":"Without any significant difference, we can also simulate three-dimensional random walks.","category":"page"},{"location":"examples/RandomWalks/3_randomwalk3D/","page":"3D Random walk","title":"3D Random walk","text":"using MicrobeAgents\nusing Distributions\nusing Plots\n\nL = 500\nspace = ContinuousSpace((L,L,L))\ndt = 0.1\nmodel = StandardABM(Microbe{3}, space, dt)\n\nadd_agent!(model; motility=RunReverse(speed=[55]), rotational_diffusivity=0.2)\nadd_agent!(model; motility=RunTumble(speed=Normal(30,6)), turn_rate=0.5)\nadd_agent!(model; motility=RunReverseFlick(speed_backward=[6]), rotational_diffusivity=0.1)\n\nnsteps = 600\nadata = [position]\nadf, _ = run!(model, nsteps; adata)\n\nAnalysis.unfold!(adf, model)\ntraj = Analysis.adf_to_matrix(adf, :position_unfold)\nx = first.(traj)\ny = getindex.(traj, 2)\nz = last.(traj)\nt = axes(x,1) .* dt\n\nplot(x, y, z, xlab=\"x\", ylab=\"y\", zlab=\"z\", lw=2, ratio=1,\n    lab=[\"RunReverse\" \"RunTumble\" \"RunReverseFlick\"]\n)","category":"page"},{"location":"examples/RandomWalks/2_randomwalk2D_motilepatterns/","page":"2D Random walk and motile patterns","title":"2D Random walk and motile patterns","text":"EditURL = \"../../../../examples/RandomWalks/2_randomwalk2D_motilepatterns.jl\"","category":"page"},{"location":"examples/RandomWalks/2_randomwalk2D_motilepatterns/#2D-Random-walk-and-motile-patterns","page":"2D Random walk and motile patterns","title":"2D Random walk and motile patterns","text":"","category":"section"},{"location":"examples/RandomWalks/2_randomwalk2D_motilepatterns/","page":"2D Random walk and motile patterns","title":"2D Random walk and motile patterns","text":"Here we will simulate two dimensional random walk with different motile patterns.","category":"page"},{"location":"examples/RandomWalks/2_randomwalk2D_motilepatterns/","page":"2D Random walk and motile patterns","title":"2D Random walk and motile patterns","text":"As usual we start by setting up the model.","category":"page"},{"location":"examples/RandomWalks/2_randomwalk2D_motilepatterns/","page":"2D Random walk and motile patterns","title":"2D Random walk and motile patterns","text":"using MicrobeAgents\nusing Distributions\nusing Plots\n\nL = 500 # space size in μm\nspace = ContinuousSpace((L,L)) # defaults to periodic\ndt = 0.1 # integration timestep in s\nmodel = StandardABM(Microbe{2}, space, dt)","category":"page"},{"location":"examples/RandomWalks/2_randomwalk2D_motilepatterns/","page":"2D Random walk and motile patterns","title":"2D Random walk and motile patterns","text":"We will now add microbes individually, choosing different properties for each. The motile pattern can be customized through the motility keyword.","category":"page"},{"location":"examples/RandomWalks/2_randomwalk2D_motilepatterns/","page":"2D Random walk and motile patterns","title":"2D Random walk and motile patterns","text":"The RunTumble motility consists of straight runs interspersed with isotropic reorientations (tumbles). We can define the speed of follow a a Normal distribution (from Distributions.jl) with mean 30 μm/s and standard deviation 6 μm/s. This means that, after every tumble, the microbe will change its speed following this distribution. Further, we reduce the unbiased tumbling rate (turn_rate) of the microbe from the default value of 1 Hz to 0.5 Hz.","category":"page"},{"location":"examples/RandomWalks/2_randomwalk2D_motilepatterns/","page":"2D Random walk and motile patterns","title":"2D Random walk and motile patterns","text":"add_agent!(model; motility=RunTumble(speed=Normal(30,6)), turn_rate=0.5)","category":"page"},{"location":"examples/RandomWalks/2_randomwalk2D_motilepatterns/","page":"2D Random walk and motile patterns","title":"2D Random walk and motile patterns","text":"The RunReverse motility consists of alternating straight runs and 180-degree reversals. Differently from the RunTumble, the RunReverse can be considered as a two-step motility pattern and we can assign different properties to the \"forward\" and the \"backward\" state of motion. If no properties are explicitly specified for the \"backward\" state, it will inherit those of the \"forward\" state. Here we just set the speed to the constant value of 55 μm/s. Further, we set the rotational_diffusivity of the microbe to 0.2 rad²/s; in absence of rotational diffusion, the run reverse motility is pathologically incapable of exploring space efficiently.","category":"page"},{"location":"examples/RandomWalks/2_randomwalk2D_motilepatterns/","page":"2D Random walk and motile patterns","title":"2D Random walk and motile patterns","text":"add_agent!(model; motility=RunReverse(speed=[55]), rotational_diffusivity=0.2)","category":"page"},{"location":"examples/RandomWalks/2_randomwalk2D_motilepatterns/","page":"2D Random walk and motile patterns","title":"2D Random walk and motile patterns","text":"The RunReverseFlick motility consists of a straight run, a 180-degree reversal, then another straight run followed by a 90-degree reorientation (the flick). Like the RunReverse, this is a two-step motility pattern; indeed, we can imagine it as a RunReverse where the reorientation in the \"backward\" motile state is 90 instead of 180 degrees. We set the speed_backward to 6 μm/s, while the speed in the forward mode will keep its default value (30 μm/s). We also set the rotational diffusivity to 0.1 rad²/s.","category":"page"},{"location":"examples/RandomWalks/2_randomwalk2D_motilepatterns/","page":"2D Random walk and motile patterns","title":"2D Random walk and motile patterns","text":"add_agent!(model; motility=RunReverseFlick(speed_backward=[6]), rotational_diffusivity=0.1)","category":"page"},{"location":"examples/RandomWalks/2_randomwalk2D_motilepatterns/","page":"2D Random walk and motile patterns","title":"2D Random walk and motile patterns","text":"Now we can run (collecting the microbe positions at each timestep), unfold the trajectories, and visualize them.","category":"page"},{"location":"examples/RandomWalks/2_randomwalk2D_motilepatterns/","page":"2D Random walk and motile patterns","title":"2D Random walk and motile patterns","text":"nsteps = 600\nadata = [position]\nadf, _ = run!(model, nsteps; adata)\n\nAnalysis.unfold!(adf, model)\ntraj = Analysis.adf_to_matrix(adf, :position_unfold)\nx = first.(traj)\ny = last.(traj)\nt = axes(x,1) .* dt\n\nplot(x, y, xlab=\"x\", ylab=\"y\", ratio=1,\n    lab=[\"RunTumble\" \"RunReverse\" \"RunReverseFlick\"]\n)","category":"page"},{"location":"examples/Chemotaxis/3_xie_response-function/","page":"Response function (Xie)","title":"Response function (Xie)","text":"EditURL = \"../../../../examples/Chemotaxis/3_xie_response-function.jl\"","category":"page"},{"location":"examples/Chemotaxis/3_xie_response-function/#Response-function-(Xie)","page":"Response function (Xie)","title":"Response function (Xie)","text":"","category":"section"},{"location":"examples/Chemotaxis/3_xie_response-function/","page":"Response function (Xie)","title":"Response function (Xie)","text":"In this example we will probe the response function implemented in the Xie model of chemotaxis. The impulse response function is the \"output\" of the bacterial chemotaxis pathway when presented with an input signal`.","category":"page"},{"location":"examples/Chemotaxis/3_xie_response-function/","page":"Response function (Xie)","title":"Response function (Xie)","text":"To do this, we will emulate another classical laboratory assay, where the bacterium is tethered to a wall, and it is exposed to a temporal change in the concentration of a chemoattractant. The response to the stimulus can be measured by observing modulations in the instantaneous tumbling rate. For each of the implemented microbe types, MicrobeAgents provides a tumblebias function which returns the instantaneous bias in the tumbling rate, evaluated from the internal state of the microbe. Monitoring the time evolution of the tumble bias under teporal stimuli then allows us to access the response function of the microbe.","category":"page"},{"location":"examples/Chemotaxis/3_xie_response-function/","page":"Response function (Xie)","title":"Response function (Xie)","text":"In the Xie model, chemotaxis is implemented by direct samplings of the concentration_field, thus we don't need to explicitly define neither a concentration_gradient nor a concentration_time_derivative. We will represent our temporal stimuli in the form of square waves which instantaneously switch from a baseline value C₀ to a peak value C₁+C₀ homogeneously over space. The excitation will occur at a time t₁ and go back to baseline levels at a time t₂.","category":"page"},{"location":"examples/Chemotaxis/3_xie_response-function/","page":"Response function (Xie)","title":"Response function (Xie)","text":"using MicrobeAgents\nusing Plots\n\nθ(a,b) = a>b ? 1.0 : 0.0 # heaviside theta function\nfunction concentration_field(pos, model)\n    C₀ = model.C₀\n    C₁ = model.C₁\n    t₁ = model.t₁\n    t₂ = model.t₂\n    dt = model.timestep\n    t = abmtime(model) * dt\n    # notice the time dependence!\n    concentration_field(t, C₀, C₁, t₁, t₂)\nend\nconcentration_field(t,C₀,C₁,t₁,t₂) = C₀+C₁*θ(t,t₁)*(1-θ(t,t₂))\n\nspace = ContinuousSpace(ntuple(_ -> 500.0, 3)) # μm\nC₀ = 0.01 # μM\nC₁ = 5.0-C₀ # μM\nT = 60.0 # s\nt₁ = 20.0 # s\nt₂ = 40.0 # s\nproperties = Dict(\n    :chemoattractant => GenericChemoattractant{3,Float64}(; concentration_field),\n    :C₀ => C₀,\n    :C₁ => C₁,\n    :t₁ => t₁,\n    :t₂ => t₂,\n)\n\ndt = 0.1 # s\nmodel = StandardABM(Xie{3}, space, dt; properties)","category":"page"},{"location":"examples/Chemotaxis/3_xie_response-function/","page":"Response function (Xie)","title":"Response function (Xie)","text":"A peculiarity of the Xie model is that the chemotactic properties of the microbe differ between the forward and backward motile states, so we can probe the response function in both the forward and backward motile state by initializing two distinct microbes in the two states. To keep the microbes in these motile states for the entire experiment duration, we suppress their tumbles, and (just for total consistency with experiments) we also set their speed to 0.","category":"page"},{"location":"examples/Chemotaxis/3_xie_response-function/","page":"Response function (Xie)","title":"Response function (Xie)","text":"add_agent!(model; turn_rate_forward=0,\n    motility=RunReverseFlick(motile_state=MotileState(Forward), speed=[0])\n)\nadd_agent!(model; turn_rate_backward=0,\n    motility=RunReverseFlick(motile_state=MotileState(Backward), speed=[0])\n)","category":"page"},{"location":"examples/Chemotaxis/3_xie_response-function/","page":"Response function (Xie)","title":"Response function (Xie)","text":"In addition to the tumblebias, we will also monitor two other quantities state_m and state_z which are internal variables of the Xie model which represent the methylation and dephosphorylation processes which together control the chemotactic response of the bacterium.","category":"page"},{"location":"examples/Chemotaxis/3_xie_response-function/","page":"Response function (Xie)","title":"Response function (Xie)","text":"nsteps = round(Int, T/dt)\nadata = [tumblebias, :state_m, :state_z]\nadf, = run!(model, nsteps; adata)\n\nS = Analysis.adf_to_matrix(adf, :tumblebias)\nm = (Analysis.adf_to_matrix(adf, :state_m))[:,1] # take only fw\nz = (Analysis.adf_to_matrix(adf, :state_z))[:,1] # take only fw","category":"page"},{"location":"examples/Chemotaxis/3_xie_response-function/","page":"Response function (Xie)","title":"Response function (Xie)","text":"We first look at the response function in the forward and backward motile state: when the concentration increases we have a sharp negative response (the tumble bias decreases), then the bacterium adapts to the new concentration level, and when it drops back to the basal level we observe a sharp positive response (the tumble bisa increases) before adapting again to the new concentration level.","category":"page"},{"location":"examples/Chemotaxis/3_xie_response-function/","page":"Response function (Xie)","title":"Response function (Xie)","text":"_green = palette(:default)[3]\nplot()\nx = (0:dt:T) .- t₁\nplot!(\n    x, S,\n    lw=1.5, lab=[\"Forward\" \"Backward\"]\n)\nplot!(ylims=(-0.1,4.5), ylab=\"Response\", xlab=\"time (s)\")\nplot!(twinx(),\n    x, t -> concentration_field(t.+t₁,C₀,C₁,t₁,t₂),\n    ls=:dash, lw=1.5, lc=_green, lab=false,\n    tickfontcolor=_green,\n    ylab=\"C (μM)\", guidefontcolor=_green\n)","category":"page"},{"location":"examples/Chemotaxis/3_xie_response-function/","page":"Response function (Xie)","title":"Response function (Xie)","text":"By analysing the methylation and dephosphorylation processes, we can understand how the chemotactic response arises. First, when the concentration increases, both m and z increase and converge to a new steady-state value, but since they respond on different timescales, the response (defined by the difference between these two quantities), shows a sharp decrease followed by a slower relaxation. The same occurs for the negative stimulus.","category":"page"},{"location":"examples/Chemotaxis/3_xie_response-function/","page":"Response function (Xie)","title":"Response function (Xie)","text":"x = (0:dt:T) .- t₁\nτ_m = model[1].adaptation_time_m\nτ_z = model[1].adaptation_time_z\nM = m ./ τ_m\nZ = z ./ τ_z\nR = M .- Z\nplot(\n    x, [M Z R],\n    lw=2,\n    lab=[\"m/τ_m\" \"z/τ_z\" \"m/τ_m - z/τ_z\"],\n    xlab=\"time (s)\"\n)","category":"page"},{"location":"examples/Chemotaxis/1_linear_ramp/","page":"Linear concentration ramp","title":"Linear concentration ramp","text":"EditURL = \"../../../../examples/Chemotaxis/1_linear_ramp.jl\"","category":"page"},{"location":"examples/Chemotaxis/1_linear_ramp/#Linear-concentration-ramp","page":"Linear concentration ramp","title":"Linear concentration ramp","text":"","category":"section"},{"location":"examples/Chemotaxis/1_linear_ramp/","page":"Linear concentration ramp","title":"Linear concentration ramp","text":"In this example we will setup an in-silico version of a typical laboratory assay, with chemotactic bacteria moving in a linear concentration ramp, i.e. a concentration field of the form","category":"page"},{"location":"examples/Chemotaxis/1_linear_ramp/","page":"Linear concentration ramp","title":"Linear concentration ramp","text":"C(x) = C_0 + (C_1 - C_0)dfracxL_x qquad x in 0L_x","category":"page"},{"location":"examples/Chemotaxis/1_linear_ramp/","page":"Linear concentration ramp","title":"Linear concentration ramp","text":"We will create a closed two-dimensional domain, mimicking a thin microfluidic chamber, with a length of 3 mm along the x direction, and 1.5 mm along the y direction. We will then setup the concentration field along the x direction and observe chemotactic microbes as they drift towards the high-concentration region of the chamber.","category":"page"},{"location":"examples/Chemotaxis/1_linear_ramp/","page":"Linear concentration ramp","title":"Linear concentration ramp","text":"The first thing we have to do is define two functions for the concentration_field and the concentration_gradient. They must take as arguments the position of a single microbe, and the model (from which we can access other properties of the system). Of course, for our convenience we can dispatch these functions on whatever arguments we want, as long as they have a method whose signature matches the MicrobeAgents API.","category":"page"},{"location":"examples/Chemotaxis/1_linear_ramp/","page":"Linear concentration ramp","title":"Linear concentration ramp","text":"Importantly, the concentration_field must return a scalar, non-negative value. Since the gradient is a vector quantity, the concentration_gradient should instead return an iterable with length equal to the system dimensionality; a SVector is the recommended choice, but NTuples, Vectors, etc.. work just fine.","category":"page"},{"location":"examples/Chemotaxis/1_linear_ramp/","page":"Linear concentration ramp","title":"Linear concentration ramp","text":"All the parameters that we need to evaluate the concentration field and gradient, in our case the two concentration values C₀ and C₁ and the chamber length Lx, should be extracted from the model.","category":"page"},{"location":"examples/Chemotaxis/1_linear_ramp/","page":"Linear concentration ramp","title":"Linear concentration ramp","text":"using MicrobeAgents\nusing Plots\n\n@inline function concentration_field(pos, model)\n    C₀ = model.C₀\n    C₁ = model.C₁\n    Lx = first(spacesize(model))\n    concentration_field(pos,Lx,C₀,C₁)\nend\n@inline concentration_field(pos,Lx,C₀,C₁) = C₀ + (C₁-C₀)*pos[1]/Lx\n\n@inline function concentration_gradient(pos, model)\n    C₀ = model.C₀\n    C₁ = model.C₁\n    Lx = first(spacesize(model))\n    concentration_gradient(pos,Lx,C₀,C₁)\nend\n@inline concentration_gradient(pos,Lx,C₀,C₁) = SVector{length(pos)}(i==1 ? (C₁-C₀)/Lx : 0.0 for i in eachindex(pos))","category":"page"},{"location":"examples/Chemotaxis/1_linear_ramp/","page":"Linear concentration ramp","title":"Linear concentration ramp","text":"Now as usual we define the simulation domain and the integration timestep, but we also define a properties dictionary, which we pass as a keyword argument to StandardABM. This dictionary will contain all the information regarding our concentration field.","category":"page"},{"location":"examples/Chemotaxis/1_linear_ramp/","page":"Linear concentration ramp","title":"Linear concentration ramp","text":"Note that the :C₀ and :C₁ keys have been defined by us; we could have chosen different names for them. The concentration_field and concentration_gradient functions instead must be wrapped into an AbstractChemoattractant type and attached to the :chemoattractant keyword; this is required by MicrobeAgents and assigning these functions to any other key will not produce the desired results. In this example, we define the chemoattractant as a GenericChemoattractant, a default wrapper which takes concentration_field and concentration_gradient as keyword arguments. Notice it also takes the model dimensionality and number type as parameters.","category":"page"},{"location":"examples/Chemotaxis/1_linear_ramp/","page":"Linear concentration ramp","title":"Linear concentration ramp","text":"Finally, to observe chemotaxis, we must use a microbe type for which chemotactic behavior is implemented. If we used the base Microbe, no matter what field we define, we would only observe a random walk since no chemotactic behavior is implemented. The most classic model of chemotaxis is implemented in the BrownBerg type; we will not modify its parameters here and just stick to the default values.","category":"page"},{"location":"examples/Chemotaxis/1_linear_ramp/","page":"Linear concentration ramp","title":"Linear concentration ramp","text":"Lx, Ly = 3000, 1500 # domain size (μm)\nperiodic = false\nspace = ContinuousSpace((Lx,Ly); periodic)\nΔt = 0.1 # timestep (s)\n\n# model setup\nC₀, C₁ = 0.0, 20.0 # μM\nproperties = Dict(\n    :C₀ => C₀,\n    :C₁ => C₁,\n    :chemoattractant => GenericChemoattractant{2,Float64}(;\n        concentration_field, concentration_gradient\n    )\n)\nmodel = StandardABM(BrownBerg{2}, space, Δt; properties)\nn = 100 # number of microbes\nfor i in 1:n\n    add_agent!(model) # add at random positions\nend\nmodel","category":"page"},{"location":"examples/Chemotaxis/1_linear_ramp/","page":"Linear concentration ramp","title":"Linear concentration ramp","text":"Now that the model is created, we just run it as usual, collecting the position of the microbes at each timestep. The visualization is slightly more involved since we want to plot the microbe trajectories on top of the concentration field shown as a heatmap, but there is really no difference from what we have seen in the random walk examples.","category":"page"},{"location":"examples/Chemotaxis/1_linear_ramp/","page":"Linear concentration ramp","title":"Linear concentration ramp","text":"In the figure, we will see that all the microbes drift towards the right, where the concentration of the attractant is higher.","category":"page"},{"location":"examples/Chemotaxis/1_linear_ramp/","page":"Linear concentration ramp","title":"Linear concentration ramp","text":"T = 120 # simulation time (s)\nnsteps = round(Int, T/Δt)\nadata = [position]\nadf, mdf = run!(model, nsteps; adata)\n\ntraj = Analysis.adf_to_matrix(adf, :position)\nx = first.(traj)\ny = last.(traj)\n\nts = unique(adf.step) .* Δt\nlw = eachindex(ts) ./ length(ts) .* 3\nxmesh = range(0,Lx,length=100)\nymesh = range(0,Ly,length=100)\nxn = @view x[:,1:10]\nyn = @view y[:,1:10]\nc = concentration_field.(Iterators.product(xmesh,ymesh),Lx,C₀,C₁)\nheatmap(xmesh, ymesh, c', cbar=false, c=:bone,\n    ratio=1, axis=false, grid=false, xlims=(0,Lx), ylims=(0,Ly)\n)\nplot!(xn, yn, lab=false, lw=lw, lc=(1:n)')\nscatter!(xn[end,:], yn[end,:], lab=false, m=:c, mc=1:n, msw=0.5, ms=8)","category":"page"},{"location":"validation/msd_runtumble/","page":"Mean squared displacement","title":"Mean squared displacement","text":"EditURL = \"../../../examples/Validation/msd_runtumble.jl\"","category":"page"},{"location":"validation/msd_runtumble/#Mean-squared-displacement","page":"Mean squared displacement","title":"Mean squared displacement","text":"","category":"section"},{"location":"validation/msd_runtumble/","page":"Mean squared displacement","title":"Mean squared displacement","text":"The mean squared displacement (MSD) of a population of run-tumble swimmers with an average turn angle theta, should obey, in the absence of rotational diffusion, the following equation (Taktikos et al (PLoS ONE 2012)):","category":"page"},{"location":"validation/msd_runtumble/","page":"Mean squared displacement","title":"Mean squared displacement","text":"textMSD(t) = 2v^2tildetau^2\nleft( dfracttildetau - 1 + exp(-ttildetau) right)","category":"page"},{"location":"validation/msd_runtumble/","page":"Mean squared displacement","title":"Mean squared displacement","text":"where v is the microbe velocity, and tildetau = tau(1-costheta) is the correlation-corrected effective run length.","category":"page"},{"location":"validation/msd_runtumble/","page":"Mean squared displacement","title":"Mean squared displacement","text":"To test this, we will simulate run-tumble motility with different distributions of polar reorientation angles and evaluate their MSDs. For simplicity, since only the average angle matters rather than the entire distribution, we will only allow microbes to perform rotations of angle θ (and -θ for symmetry).","category":"page"},{"location":"validation/msd_runtumble/","page":"Mean squared displacement","title":"Mean squared displacement","text":"using MicrobeAgents\nusing Plots\n\ndt = 0.05 # s\nL = 500.0 # μm\nextent = (L,L,L)\nspace = ContinuousSpace(extent)\n\nθs = [π/6, π/4, π/3, π/2, π]\nα = cos.(θs)\n\nU = 30.0 # μm/s\nτ = 1.0 # s\nturn_rate = 1 / τ\n\n# we initialize a separate model for each different θ\nmodels = map(_ -> StandardABM(Microbe{3}, space, dt; container=Vector), θs)\nnmicrobes = 100\nfor (i,θ) in enumerate(θs)\n    motility = RunTumble(speed=[U], polar=[θ,-θ])\n    foreach(_ -> add_agent!(models[i]; motility, turn_rate), 1:nmicrobes)\nend\n\nnsteps = round(Int, 100τ / dt)\nadata = [position]\nadfs = [run!(model, nsteps; adata)[1] for model in models]\n\nforeach(adf -> Analysis.unfold!(adf, extent), adfs)\nMSD = hcat([Analysis.emsd(adf, :position_unfold)[2:end] for adf in adfs]...)\n\nt = (1:nsteps).*dt\nβ = cos.(θs)\nT = @. τ / (1-β')\ns = t ./ T\nD = @. U^2*T/3\nMSD_theoretical = @. 6D*T * (s - 1 + exp(-s))\nplot(\n    xlab = \"Δt / τ\",\n    ylab = \"MSD / (Uτ)²\",\n    legend = :bottomright, legendtitle = \"1-cosθ\",\n    scale = :log10,\n    yticks = exp10.(-2:2:2),\n    xticks = exp10.(-2:2)\n)\n# show simulation values only at selected lags\nlags = round.(Int, exp10.(range(0, 3, length=20))) |> unique\nscatter!(t[lags]./τ, MSD[lags,:]./(U*τ)^2,\n    m=:x, ms=6, msw=2, lab=false, lc=axes(β,1)'\n)\nplot!(t./τ, MSD_theoretical./(U*τ)^2,\n    lw=2, lab=round.(1 .- β,digits=2)', lc=axes(β,1)'\n)","category":"page"},{"location":"validation/#Validation","page":"Validation","title":"Validation","text":"","category":"section"},{"location":"validation/#Run-Time-Distribution","page":"Validation","title":"Run Time Distribution","text":"","category":"section"},{"location":"validation/","page":"Validation","title":"Validation","text":"(examples/Analysis/run_distribution.jl) Run times should be exponentially distributed, with tau being the inverse of the average turn rate.","category":"page"},{"location":"validation/","page":"Validation","title":"Validation","text":"(Image: Exponential distribution of run times)","category":"page"},{"location":"validation/","page":"Validation","title":"Validation","text":"The smaller the timestep Delta t compared to the average run length tau, the better the agreement between numerical results and theory. A ratio tau  Delta t sim 10 is typically sufficient to have a reasonable agreement.","category":"page"},{"location":"validation/#Velocity-Autocorrelation-Function","page":"Validation","title":"Velocity Autocorrelation Function","text":"","category":"section"},{"location":"validation/","page":"Validation","title":"Validation","text":"Velocity autocorrelation functions for the three motility patterns should obey the following equations (Taktikos et al. PLoS ONE 2012): `` \\phi(t) = \\begin{cases}   \\text{exp}(-t/\\tau), & \\text{run-tumble} \\\n  \\text{exp}(-2t/\\tau), & \\text{run-reverse} \\\n  (1-t/2\\tau)\\text{exp}(-t/\\tau), & \\text{run-reverse-flick} \\end{cases} `` (assuming no rotational diffusion, and that forward and backward mode have identical timescales for the run-reverse-flick swimmer).","category":"page"},{"location":"validation/","page":"Validation","title":"Validation","text":"(Image: Velocity autocorrelation functions for run-tumble, run-reverse, run-reverse-flick)","category":"page"},{"location":"validation/#Mean-Squared-Displacement","page":"Validation","title":"Mean Squared Displacement","text":"","category":"section"},{"location":"validation/","page":"Validation","title":"Validation","text":"The mean squared displacement (MSD) for a run-tumble swimmer with average turn angle theta (and without rotational diffusion) should obey the following equation (Taktikos et al. PLoS ONE 2012):","category":"page"},{"location":"validation/","page":"Validation","title":"Validation","text":"textMSD(t) = 2v^2tildetau^2 (ttildetau - 1 + e^-ttildetau) where tildetau = tau(1-costheta).","category":"page"},{"location":"validation/","page":"Validation","title":"Validation","text":"(Image: MSD of run-tumble motility with varying turn angle distributions)","category":"page"},{"location":"introduction/#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"introduction/#Structure","page":"Introduction","title":"Structure","text":"","category":"section"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"An AgentBasedModel object embeds all the properties of the system to be simulated and maps unique IDs to microbe instances. During the simulation, the model is evolved in discrete time steps, with each microbe's position, velocity and \"state\" being updated according to specified rules. Standard rules for motion, reorientations and chemotaxis are available by default, but custom behaviors can be implemented via user-defined functions.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"The typical workflow to run a simulation in MicrobeAgents.jl goes as follows:","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Define the size and properties of the space in which the microbes will move.\nChoose an appropriate microbe type to represent the desired behavior, or define a new one.\nInitialize an AgentBasedModel object with the desired space, microbe type, integration time step, and any extra property needed for the simulation.\nPopulated the ABM with microbe instances.\nChoose the observables to collect during production and run the model.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"MicrobeAgents.jl re-exports and extends various function from Agents.jl in order to work as a standalone, but it is generally recommended to use it in combination with Agents.jl for extra goodies.","category":"page"},{"location":"introduction/#Space","page":"Introduction","title":"Space","text":"","category":"section"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"MicrobAgents.jl only supports continuous spaces with dimensions 1, 2 or 3. Spaces can be created with the ContinuousSpace function (reexported from Agents.jl). The extent of the space must be given as a tuple or SVector, and periodicity is set with the periodic kwarg (defaults to true).","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"# one-dimensional periodic space\nextent = (1.0,)\nContinuousSpace(extent)\n\n# two-dimensional non-periodic space\nextent = (1.0, 2.0)\nContinuousSpace(extent; periodic=false)\n\n# three-dimensional space periodic only along the x direction\nextent = (100.0, 20.0, 20.0)\nContinuousSpace(extent; periodic=(true,false,false))","category":"page"},{"location":"introduction/#Microbes","page":"Introduction","title":"Microbes","text":"","category":"section"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Microbes are represented by subtypes of the AbstractMicrobe type, which is in turn a subtype of AbstractAgent introduced by Agents.jl","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"AbstractMicrobe","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"MicrobeAgents provides different AbstractMicrobe subtypes representing different models of bacterial behavior from the literature. The list of implemented models can be obtained with subtypes(AbstractMicrobe).","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"A basic type, which is typically sufficient for simple motility simulations and does not include chemotaxis, is the Microbe type.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Microbe","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"The dimensionality of Microbe must always be specified on creation. All the fields are instead optional, and if not specified will be assigned default values. Microbe instances should only be created within an AgentBasedModel.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"In MicrobeAgents.jl, models are created through the StandardABM function.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"StandardABM","category":"page"},{"location":"introduction/#Agents.StandardABM","page":"Introduction","title":"Agents.StandardABM","text":"StandardABM(MicrobeType, space, timestep; kwargs...)\n\nExtension of the Agents.StandardABM method for microbe types. Implementation of AgentBasedModel where agents can be added and removed at any time. If agents removal is not required, it is recommended to use the keyword argument container = Vector for better performance. See Agents.AgentBasedModel for detailed information on the keyword arguments.\n\nArguments\n\nMicrobeType: subtype of AbstractMicrobe{D}, with explicitly specified dimensionality D. A list of available options can be obtained by running subtypes(AbstractMicrobe).\nspace: a ContinuousSpace{D} with the same dimensionality D as MicrobeType which specifies the spatial properties of the simulation domain.\ntimestep: the integration timestep of the simulation.\n\nKeywords\n\nproperties: additional container of data to specify model-level properties. MicrobeAgents.jl includes a set of default properties (detailed at the end).\nscheduler = Schedulers.fastest\nrng = Random.default_rng()\nwarn = true\n\nDefault properties\n\nWhen a model is created, a default set of properties is included in the model (MicrobeAgents.default_ABM_properties):\n\nDEFAULT_ABM_PROPERTIES = Dict(\n    :chemoattractant => GenericChemoattractant{D,Float64}()\n    :affect! => chemotaxis!\n)\n\nBy including these default properties, we make sure that all the chemotaxis models will work even without extra user intervention. All these properties can be overwritten by simply passing an equivalent key to the properties dictionary when creating the model.\n\n\n\n\n\n","category":"type"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"To initialize a model we must provide the microbe type, the simulation space, and the integration timestep of the simulation. All other parameters are optional. To setup a model for Microbes living in a 1-dimensional space we can therefore run","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"space = ContinuousSpace((100.0,); periodic=false)\ndt = 0.1\nmodel = StandardABM(Microbe{1}, space, dt)","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Now, calling add_agent!(model) will populate the model with microbes of the specified type (Microbe{1}) using the default values of the constructor, and automatically generating a random position and a random velocity vector. To select a position, it can be passed as the first argument to the add_agent! call, and any other bacterial parameter can be defined via keyword arguments. All of the following are valid calls","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"# a Microbe with large radius and low tumble rate\nadd_agent!(model; radius=10.0, turn_rate=0.17)\n# a Microbe with custom position and high coefficient of rotational diffusion\nadd_agent!((53.2,), model; rotational_diffusivity=0.5)\n# a Microbe initialized with velocity to the right\nadd_agent!(model; vel=(1.0,))","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"All the other subtypes of AbstractMicrobe work in a similar way, although they will have distinct default values and extra fields. When possible, default values are typically assigned following the original implementation in the literature.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"BrownBerg\nBrumley\nCelani\nXie","category":"page"},{"location":"introduction/#More-about-models","page":"Introduction","title":"More about models","text":"","category":"section"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"MicrobeAgents.jl exploits the AgentBasedModel interface from Agents.jl. While the standard Agents.jl syntax will always work, it is typically more convenient to use the method extensions provided by MicrobeAgents.jl, which also includes some default parameters required by the simulations. If the simulation requires removal/addition of microbes, it is recommended to call StandardABM with the container=Dict keyword argument, otherwise MicrobeAgents.jl defaults to container=Vector which provides better performance.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"In addition to the microbe instances, the model should also wrap all the other information required to perform the simulation.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"MicrobeAgents.jl defines default timestepping functions which are used to evolve the microbes and the model, and are accessible through the microbe_step! and model_step! keywords in StandardABM. By default, the microbe_step! function performs, in order:","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"update microbe position according to current velocity\nrandomize the microbe orientation through rotational diffusion (if present)\nupdate internal state of the microbe (e.g. chemotaxis or other user-defined behavior)\nperform reorientation events following Poissonian statistics","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"The model_step! function instead defaults to a dummy function which does nothing. Any custom behavior can be implemented by simply modifying these two functions.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Any type of external parameter that should be used during the simulation should be passed to StandardABM through the properties dictionary.","category":"page"},{"location":"introduction/#Running-a-model","page":"Introduction","title":"Running a model","text":"","category":"section"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"After the model has been created and populated with the desired number of microbes, we are ready to run the simulation. We just need to specify how many steps we want to simulate and what data to collect during the run:","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"nsteps = 100\nadf, mdf = run!(model, nsteps; adata=[position])","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"run! will return two dataframes, one for the agent-level data (adf) and one for the model-level data (mdf, which in this case will be empty). This way, we have produced our first random walk. Since adf.position is a vector of tuples, we first have to unpack the x and y values and then we are ready to plot our trajectory.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"using Plots\nx = first.(adf.position)\ny = last.(adf.position)\nplot(x, y)","category":"page"},{"location":"introduction/#Motility-patterns","page":"Introduction","title":"Motility patterns","text":"","category":"section"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"In MicrobeAgents.jl, motility patterns are represented as instances of AbstractMotility. In particular, currently available patterns are distinguished into two further categories: AbstractMotilityOneStep or AbstractMotilityTwoStep.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"MotilityOneStep\nMotilityTwoStep","category":"page"},{"location":"introduction/#MicrobeAgents.MotilityOneStep-introduction","page":"Introduction","title":"MicrobeAgents.MotilityOneStep","text":"MotilityOneStep\n\nType for one-step motility patterns (e.g. RunTumble).\n\nA MotilityOneStep has the fields\n\nspeed: distribution of microbe speed, new values extracted after each turn\npolar: distribution of polar angles\nazimuthal: distribution azimuthal angles\n\nFor 2-dimensional microbe types, only polar defines reorientations and azimuthal is ignored.\n\n\n\n\n\n","category":"type"},{"location":"introduction/#MicrobeAgents.MotilityTwoStep-introduction","page":"Introduction","title":"MicrobeAgents.MotilityTwoStep","text":"MotilityTwoStep\n\nType for two-step motility patterns (e.g. RunReverse, RunReverseFlick) In two-step motility patterns, the two \"steps\" can have different properties.\n\nA MotilityTwoStep has the fields\n\nspeed: distribution of microbe speed, new values extracted after each turn\npolar: distribution of in-plane reorientations for motile state fw\nazimuthal: distribution of out-of-plane reorientations for motile state fw\nspeed_backward: distribution of microbe speed, new values extracted after each turn\npolar_backward: distribution of in-plane reorientations for motile state bw\nazimuthal_backward: distribution of out-of-plane reorientations for motile state bw\nmotile_state: defines current motile state (e.g. Forward or Backward for a TwoState)\n\nFor 2-dimensional microbe types, only polar distributions define reorientations while azimuthal ones are ignored.\n\n\n\n\n\n","category":"type"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"One-step motility pattern are characterized by a single swimming stage. Two-step motility patterns instead have two stages which can have distinct properties; these two stages are referred to as \"forward\" and \"backward\" but can really represent anything.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"MicrobeAgents.jl defines three standard motility patterns:","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"RunTumble()\nRunReverse()\nRunReverseFlick()","category":"page"},{"location":"introduction/#MicrobeAgents.RunTumble-Tuple{}","page":"Introduction","title":"MicrobeAgents.RunTumble","text":"RunTumble(; speed=(30.0,), polar=Uniform(-π,π), azimuthal=Arccos())\n\nConstructor for a MotilityOneStep with default values associated to run-and-tumble motion.\n\n\n\n\n\n","category":"method"},{"location":"introduction/#MicrobeAgents.RunReverse-Tuple{}","page":"Introduction","title":"MicrobeAgents.RunReverse","text":"RunReverse(; speed=(30.0,), polar=(π,), azimuthal=Arccos(), speed_backward=speed, polar_backward=polar, azimuthal_backward=azimuthal)\n\nConstructor for a MotilityTwoStep with default values associated to run-reverse motion.\n\n\n\n\n\n","category":"method"},{"location":"introduction/#MicrobeAgents.RunReverseFlick-Tuple{}","page":"Introduction","title":"MicrobeAgents.RunReverseFlick","text":"RunReverseFlick(; speed=(30.0,), polar=(π,), azimuthal=Arccos(), speed_backward=speed, polar_backward=(-π/2,π/2), azimuthal_backward=azimuthal)\n\nConstructor for a MotilityTwoStep with default values associated to run-reverse-flick motion.\n\n\n\n\n\n","category":"method"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"The default values provided by the constructors always consider a constant swimming speed of 30 (micron/s) and \"ideal\" turn-angle distributions (isotropic for tumbles, perfect 180 and 90 degree reorientations for reverse and flicks). For more accurate simulation where the reorientation statistics of the microbes is important, appropriate distributions should be specified; the constructors will accept any object that can be sampled via rand().","category":"page"},{"location":"chemotaxis/#Chemotaxis","page":"Chemotaxis","title":"Chemotaxis","text":"","category":"section"},{"location":"chemotaxis/#Linear-concentration-ramp","page":"Chemotaxis","title":"Linear concentration ramp","text":"","category":"section"},{"location":"chemotaxis/","page":"Chemotaxis","title":"Chemotaxis","text":"As a first step into the world of chemotaxis, we will reproduce an in-silico version of a classical laboratory assay: a linear concentration ramp in a rectangular channel. We will use the BrownBerg model.","category":"page"},{"location":"chemotaxis/","page":"Chemotaxis","title":"Chemotaxis","text":"To define concentration profiles, MicrobeAgents.jl expects three functions: concentration_field, concentration_gradient and concentration_time_derivative, all of which must have a method with signature (pos,model), i.e. they take as input a microbe position and the ABM object. In this example the field is static, so we won't define a time derivative.","category":"page"},{"location":"chemotaxis/","page":"Chemotaxis","title":"Chemotaxis","text":"using MicrobeAgents\n\n@inline function concentration_field(pos, model)\n    C₀ = model.C₀\n    C₁ = model.C₁\n    Lx = first(spacesize(model))\n    concentration_field(pos,Lx,C₀,C₁)\nend\n@inline concentration_field(pos,Lx,C₀,C₁) = C₀ + (C₁-C₀)*pos[1]/Lx\n\n@inline function concentration_gradient(pos, model)\n    C₀ = model.C₀\n    C₁ = model.C₁\n    Lx = first(spacesize(model))\n    concentration_gradient(pos,Lx,C₀,C₁)\nend\n@inline concentration_gradient(pos,Lx,C₀,C₁) = ntuple(i->i==1 ? (C₁-C₀)/Lx : 0.0, length(pos))","category":"page"},{"location":"chemotaxis/","page":"Chemotaxis","title":"Chemotaxis","text":"The quantities C₀ and C₁ represent the concentration values at left (x=0) and right (x=L) edges of the channel. Notice that concentration_gradient returns a Tuple with the same size as pos, not just a Number. This is required since the gradient is a vector quantity.","category":"page"},{"location":"chemotaxis/","page":"Chemotaxis","title":"Chemotaxis","text":"We can set up the ABM as usual, but we will need to supply :concentration_field and :concentration_gradient to the properties container, as well as :C₀ and :C₁. Then we can run the simulation and make a nice plot.","category":"page"},{"location":"chemotaxis/","page":"Chemotaxis","title":"Chemotaxis","text":"Lx, Ly = 3000, 1500\nextent = (Lx, Ly)\nperiodic = false\nspace = ContinuousSpace(extent; periodic)\nΔt = 0.1 # timestep (s)\nT = 120 # simulation time (s)\nnsteps = round(Int, T/Δt)\nn = 100\n\nC₀, C₁ = 0.0, 20.0 # μM\nproperties = Dict(\n    :C₀ => C₀,\n    :C₁ => C₁,\n    :concentration_field => concentration_field,\n    :concentration_gradient => concentration_gradient\n)\nmodel = StandardABM(BrownBerg{2}, space, Δt; periodic, properties, container=Vector)\nfor i in 1:n\n    add_agent!(model)\nend\n\nadata = [:pos]\nadf, mdf = run!(model, nsteps; adata)\n\ntraj = vectorize_adf_measurement(adf, :pos)\nx = first.(traj)\ny = last.(traj)\n\nts = unique(adf.step) .* Δt\nlw = eachindex(ts) ./ length(ts) .* 3\nxmesh = range(0,Lx,length=100)\nymesh = range(0,Ly,length=100)\nxn = @view x[:,1:10]\nyn = @view y[:,1:10]\nc = concentration_field.(Iterators.product(xmesh,ymesh),Lx,C₀,C₁)\nheatmap(xmesh, ymesh, c', cbar=false, ratio=1, axis=false, c=:bone)\nplot!(xn, yn, lab=false, lw=lw, lc=(1:n)')\nscatter!(xn[end,:], yn[end,:], lab=false, m=:c, mc=1:n, msw=0.5, ms=8)","category":"page"},{"location":"chemotaxis/","page":"Chemotaxis","title":"Chemotaxis","text":"(Image: Drift of chemotactic bacteria in a linear concentration ramp)","category":"page"},{"location":"#MicrobeAgents.jl","page":"Home","title":"MicrobeAgents.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"MicrobeAgents.jl is a Julia framework for agent-based simulations of bacterial motility and chemotaxis, built on the amazing Agents.jl.","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Runs in 1, 2 and 3 spatial dimensions.\nProvides various motility patterns (Run-Tumble, Run-Reverse, Run-Reverse-Flick), all with customizable speed and turn angle distributions.\nVarious models of bacterial chemotaxis (Brown & Berg, PNAS 1974; Celani & Vergassola, PNAS 2010; Xie et al, Biophys J 2014; Brumley et al, PNAS 2019).\nFast analysis routines for common quantities of interest (run statistics, MSD, autocorrelation functions, drift velocity).","category":"page"},{"location":"#Limitations-(some-may-be-temporary,-others-may-be-not)","page":"Home","title":"Limitations (some may be temporary, others may be not)","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Only continuous space models are supported\nReorientations are always assumed to be instantaneous; this approximation is really only reasonable when the integration timestep is above 50ms.\nIntegration timestep also sets the sensory integration timescale in chemotactic models.","category":"page"},{"location":"#What-this-package-is-not-good-for","page":"Home","title":"What this package is not good for","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Although, in principle, you can add arbitrary layers of complexity on top the provided interface, there are a few things for which this package is not a recommended choice.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Hydrodynamic interactions.\nAtomistic representation of biochemical pathways.","category":"page"},{"location":"#Contribute","page":"Home","title":"Contribute","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package is still in an early stage of intense development. If you would like to have support for your favorite model of chemotaxis, or need some specific features to be implemented, please open an issue. I'll try to satisfy as many requests as possible.","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you would like to take a more active part in the development, please consider contacting me directly at rfoffi@ethz.ch.","category":"page"},{"location":"#Citation","page":"Home","title":"Citation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you use this package in work that leads to a publication, please cite the GitHub repository:","category":"page"},{"location":"","page":"Home","title":"Home","text":"@misc{Foffi2023,\n    author = {Foffi, R.},\n    title = {MicrobeAgents.jl},\n    year = {2023},\n    publisher = {GitHub},\n    journal = {GitHub repository},\n    howpublished = {\\url{https://github.com/mastrof/MicrobeAgents.jl}}\n}","category":"page"},{"location":"#Acknowledgements","page":"Home","title":"Acknowledgements","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This project has received funding from the European Union's Horizon 2020 research and innovation programme under the Marie Skłodowska-Curie grant agreement No 955910.","category":"page"}]
}
